{"title":"The Joy of Mixing Custom Elements, Web Components, and Markdown","byline":"Deane Barker","lang":"en-us","content":"<div id=\"readability-page-1\" class=\"page\"><article>\n\n    \n\n\n<hgroup>\n  \n  \n</hgroup>\n\n\n\n<header data-no-index=\"\">\n    \n  \n\n    \n      \n    \n    \n      <span>By <a href=\"https://deanebarker.net/\" rel=\"template\">Deane Barker</a></span>\n    \n    <span>•</span>\n  \n\n  \n    <span><time datetime=\"2025-08-09\">August 9, 2025</time></span>\n    <span>•</span>\n  \n  \n  \n\n</header>\n\n\n\n\n\n    \n\n\n\n\n    \n\n\n    \n\n    \n\n\n<p>I love Markdown. I write faster and more natively in it than any other format or tool.</p>\n<p>If we zoom way out, here’s the most basic philosophy of Markdown: replace complicated stuff with simpler stuff.</p>\n<p>That’s all it does, really. It replaces some tedious nested taggy stuff with way simpler stuff that makes more visual sense and is  faster to type. At its core, Markdown is really just a bunch of macros.</p>\n<p>This website runs on 6,000-ish Markdown files. They’re processed on the server – meaning the <a href=\"https://github.com/xoofx/markdig\">Markdig library</a> from .NET processes them, then sends back the resulting HTML. I’m all-in on Markdown, to the point where I wrote my own online editor for it.</p>\n<p>Server-side processing of Markdown is a pretty common model – most static site generators fundamentally do the same thing: they process the Markdown, turn it into HTML, and that gets sent to the server (via being written to files).</p>\n<p>One of the philosophical points of Markdown is that you can mix it with HTML. Meaning, a Markdown parser is supposed to leave HTML alone – if a line of text looks like it has some tags, the parser should skip it.</p>\n<p>This means you can do this:</p>\n<pre><code>This is some **Markdown!**\n\n&lt;img src=\"yay.jpg\" /&gt;\n\nThis is some more ***Markdown!***\n</code></pre>\n<p>And that should work fine. The first and last lines will be processed and transformed, and the middle line will be left alone and output as it’s written.</p>\n<p>These were <a href=\"https://daringfireball.net/projects/markdown/syntax#html\">the original rules</a> around inline HTML in Markdown:</p>\n<blockquote>\n<p>The only restrictions are that block-level HTML elements […] must be separated from surrounding content by blank lines, and the start and end tags of the block should not be indented with tabs or spaces.</p>\n</blockquote>\n<p>I didn’t find the need for blank lines in <a href=\"https://spec.commonmark.org/0.31.2/#html-blocks\">the CommonMark spec</a>, but just note that every Markdown processor might be a little different in this respect, so test.</p>\n<p>Anyway, we’ll likely get HTML that’s something like this out of the above Markdown.</p>\n<pre><code>&lt;p&gt;This is some &lt;strong&gt;Markdown!&lt;/strong&gt;&lt;/p&gt;\n&lt;img src=\"yay.jpg\" /&gt;\n&lt;p&gt;This is some more &lt;em&gt;&lt;strong&gt;Markdown!&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;\n</code></pre>\n<p>Our <code>img</code> tag is intact and has been left alone.</p>\n<p>This is great, and helps you in some sticky situations. You can effectively “escape out” to HTML when you need to.</p>\n\n<p>However, this still leaves you with the problem where you might have a bunch of complicated, tedious HTML that forms a repeatable component of some kind that you don’t want to hand-manage and reproduce over and over. What if you want a Markdown-friendly way to represent a feedback form, or a tabbed UI, or a mortgage calculator, or something else way beyond the scope of text formatting.</p>\n<p>For these situations, what you really want is to put a token or a placeholder in your Markdown, and have something else <em>expand</em> it later on into a larger, more complicated HTML construct.</p>\n<p>What you sort of need is… Markdown for More Complicated HTML™.</p>\n<p>Enter <a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_custom_elements\">Custom Elements</a>.</p>\n<p>These have been around a long time. They tend to get lost behind all the attention paid to the big client-side frameworks like React, but the first public spec was published in 2013, finalized in 2016, and we’ve had broad browser support since 2018 or so.</p>\n\n<p>Custom Elements can do a lot, but a core function is that they divorce the source markup from what’s effectively output into the DOM.</p>\n<p>You can write X in the markup; the Custom Element will output Y into the DOM.</p>\n<p>X is simple; Y is way more complicated.</p>\n<p>X is written by an editor; Y is written by logical processing.</p>\n<p>So, considered at that level, Custom Elements can be used as… HTML <em>macros</em>.</p>\n<p>This means that when you combine them with Markdown, you get a really neat synergy of features.</p>\n<ul>\n<li>Markdown expands into text formatting</li>\n<li>Custom Elements (that the Markdown processor ignores) expands into more complicated stuff</li>\n</ul>\n<p>Consider this scenario: you have a blog post which is Part 1 of a series. You want to let people subscribe to be notified about Part 2, but that involves a little widget of some kind in the HTML. And for whatever reason, you have to put this between two paragraphs.</p>\n<p>What if you could do this:</p>\n<pre><code>This is some **Markdown!**\n\n&lt;subscribe-to /&gt;\n\nThis is some more **Markdown!**\n</code></pre>\n<p>(Remember, that middle line is HTML, so the Markdown processor will leave it alone.)</p>\n<p>Then, in the browser, that <code>subscribe-to</code> tag will expand into something like this:</p>\n<pre><code>&lt;div part=\"outer\"&gt;\n  &lt;label part=\"label\"&gt;Want to know when Part 2 is published?&lt;/label&gt;\n  &lt;input part=\"input\" type=\"text\" name=\"email\" placeholder=\"Give us your email\"&gt;\n  &lt;button part=\"button\" type=\"button\"&gt;Let me know!&lt;/button&gt;\n&lt;/div&gt;\n</code></pre>\n<p>This is <em>exactly</em> what Custom Elements can do.</p>\n<p>To be clear, this is <em>not</em> a tutorial about Custom Elements in general – there’s a lot of depth there – but just a joyful discovery of what happens when we combine them with hand-written Markdown and come to the conclusion that both Custom Elements and Markdown sort of operate on the same principle from the perspective of the writer: they replace simpler stuff with more complex stuff.</p>\n<p>Custom Elements can just be simple tokens like the above (actually, what’s above is not quite valid, but more on that below), or you can expose configuration parameters to make them more usable in more situations:</p>\n<pre><code>This is some **Markdown!**\n\n&lt;subscribe-to buttonText=\"Get me the details!\" /&gt;\n\nThis is some more **Markdown!**\n</code></pre>\n<p>You can even put stuff between Custom Element tags then use that in the processing and output. (You can go even further, by defining child tag structures and “slots” and all sorts of stuff that we won’t get into. Again, there’s <em>so</em> much depth there…)</p>\n<pre><code>This is some **Markdown!**\n\n&lt;subscribe-to&gt;\n\nWe'll use your email once, then delete it. _We promise!_\n\n&lt;/subscribe-to&gt;\n\nThis is some more **Markdown!**\n</code></pre>\n<p>Guess what happens to that line between the <code>subscribe-to</code> tags? Yes, it gets processed by the Markdown engine, <em>because it’s not HTML</em> – there’s no tag on that line. So the Markdown engine will process it, but leave the line above and below it alone, resulting in this:</p>\n<pre><code>&lt;subscribe-to&gt;\n  &lt;p&gt;We'll use your email once, then delete it. &lt;em&gt;We promise!&lt;/em&gt;&lt;/p&gt;\n&lt;/subscribe-to&gt;\n</code></pre>\n\n<p>During a bout of insomnia, I did some local testing of the general theory.</p>\n<p>I had <a href=\"https://claude.ai/\">Claude</a> vibe-code a simple Node script that read a Markdown file which looked a lot like the samples above (Markdown paragraphs above and below, with a <code>subscribe-to</code> Custom Element in the middle). Then it processed the Markdown – Custom Element included – and output the result into a file.</p>\n<p><a href=\"https://deanebarker.net/tech/blog/images/custom-elements-markdown/content.txt\">Here’s the Markdown source.</a> There are two <code>subscribe-to</code> tags in there – one simple version, and one with a bunch of options I thought up.</p>\n<p>You can see that when the browser encounters this – </p>\n<pre><code>&lt;subscribe-to /&gt;\n</code></pre>\n<p>– it expands into HTML (in a shadow DOM) that ends up looking like this in the browser:</p>\n\n\n\n\n\n\n\n\n<picture><source srcset=\"https://deanebarker.net/tech/blog/images/custom-elements-markdown/custom-elements-markdown.png?w=480\" media=\"(max-width: 480px)\"><img src=\"https://deanebarker.net/tech/blog/images/custom-elements-markdown/custom-elements-markdown.png?w=700\" loading=\"lazy\" width=\"700\" height=\"167\"></picture>\n\n\n\n<p>Or this when you add some advanced options:</p>\n\n\n\n\n\n\n\n\n<picture><source srcset=\"https://deanebarker.net/tech/blog/images/custom-elements-markdown/custom-elements-markdown-adv.png?w=480\" media=\"(max-width: 480px)\"><img src=\"https://deanebarker.net/tech/blog/images/custom-elements-markdown/custom-elements-markdown-adv.png?w=700\" loading=\"lazy\" width=\"700\" height=\"201\"></picture>\n\n\n\n<p><a href=\"https://deanebarker.net/tech/blog/images/custom-elements-markdown/output.html\">Here’s the output file.</a></p>\n<p>(That’s raw HTML; you can view the source. Understand that it’s still <code>subscribe-to</code> in the source, but inspect the DOM and you can see what it effectively expands into. The JavaScript definition for the Custom Element is inline in the HTML doc. I used <a href=\"https://lit.dev/\">Lit</a> as a base because it makes a lot of things <em>so</em> much easier.)</p>\n<p>I just <em>love</em> this.</p>\n<p>An editor has Markdown acting as text macros, Custom Elements acting as HTML macros, <em>and they can mix the two in the same file</em>.  Simpler things become more complicated things. They can use Gruber’s “escape hatch” to handle infinitely complexity while being abstracted away from verbosity.</p>\n<p>This opens some lovely possibilities for page, layout, and element complexity and functionality while retaining the “I wrote it in a simple text editor!” joy that made Markdown so awesome to start with.</p>\n<h2>Postscript: Minor Technical Note</h2>\n<p>I’ve been lying to you a little in this entire document. You actually can’t do this:</p>\n<pre><code>&lt;subscribe-to /&gt;\n</code></pre>\n<p>Custom Elements cannot be self-closing (or a “void tag,” as they’re called). You technically have to do this:</p>\n<pre><code>&lt;subscribe-to&gt;&lt;/subscribe-to&gt;\n</code></pre>\n<p>The self-closing version will work sometimes, kind of accidentally. Where it falls apart is when you put something between the tags, because the browser considers the self-closing tag as just the <em>opening</em> tag, which it then claims never closes.</p>\n<p>But here’s how and why I started <del>lying to you</del> displaying the self-closing version.</p>\n<p>Because – and stick with me here – here’s something <em>else</em> you can’t do: put your tag attributes on multiple lines.</p>\n<pre><code>&lt;subscribe-to\n  buttonText=\"I love getting email!\"\n  anotherAttribute=\"Another value\"\n&gt;\n</code></pre>\n<p>This time, it’s not the browser that’s the problem – the browser is totally fine with you breaking out the attributes to their own lines. This time, it’s the Markdown engine. It looks at those middle lines and decides that they’re not HTML, not understanding that it’s logically part of the opening tag. This means that – you guessed it – the Markdown engine tries to process it and everything falls apart.</p>\n<p>(As noted above, this might vary a bit between Markdown engines. Claude picked <a href=\"https://marked.js.org/\">Marked</a> for this POC.)</p>\n<p>I didn’t like that I couldn’t do this. I wanted to be able to break out all my attributes on their own lines.</p>\n<p>To solve this, I had <a href=\"https://claude.ai/\">Claude</a> vibe up a simple (?) Markdown pre-processor. So before the source Markdown got fed into Marked, some code in the Node app “fixes” the tag – reassembles it all back on the same line.</p>\n<p>And, while I was doing that, I also “fixed” the self-closing tag issue. If the code detected a self-closing tag that contained a dash (which Custom Elements must), it changed it to an explicitly closed tag. That’s why I showed you the self-closing tag. But know that by the time it got to the Markdown engine, it was explicitly closed.</p>\n<p>It was just cleaner and less confusing while I was early in the explanation.</p>\n<p>Here’s the source of the Node app with the preprocessor in a (pretty gross-looking) function called <code>preprocessMarkdown</code>.</p>\n<p>(Full disclosure: I didn’t even bother to check this. It was just a POC, so I had Claude write it. I could have written it myself, but didn’t want to put in the effort for something with no larger goal.)</p>\n<h2>Postscript: Fun and Madness with Markdown Preprocessing</h2>\n<p>Once you crack open the door of Markdown pre-processing, you can be sorely tempted to head further down that road. For instance, if you don’t like the idea of raw HTML in your Markdown, you could essentially write your own mini-language.</p>\n<p>For example, something like:</p>\n<pre><code>@:subscribe-to\n buttonText: I love email!\n placeHolder: Give us your email!\n</code></pre>\n<p>All you have to do is write some preprocessing code that detects that construct and forms it into the Custom Element tag.</p>\n\n<p>Is that “better” than raw HTML? I don’t know… maybe?</p>\n<p>The looming problem is that this is just one simplistic Custom Element example. When you get into more advanced features like child tag structures and slots and such, you’d probably end up re-interpreting and re-implementing <em>way</em> more of the HTML spec than you want to.</p>\n<p>I predict there will be a point where you regret trying to do this. Pre-processing and the initial excitement of a domain-specific language is a siren that might lead you to your doom.</p>\n<p>(I swear, I have never tried to do something this foolish… I <em>swear</em>…)</p>\n<h2>Postscript: Fun with Language Design</h2>\n<p>When you realize that Custom Elements effectively abstract writing HTML away from deeper logical programming, you realize that designing the logical interface of your Custom Elements is a fun exercise in language design.</p>\n<p>The basic principle becomes: <em>don’t ask for anything you don’t absolutely need</em>. Do as much work as possible for your editors in code. Require them to provide as little information as possible.</p>\n<p>If we want to embed a feedback form, for instance, we could do something like this:</p>\n<pre><code>&lt;input-form submitButtonText=\"Send message!\"&gt;\n  &lt;input-text label=\"Your Name\" spec=\"required &gt;4\" /&gt;\n  &lt;input-text label=\"Your Email\" spec=\"required email\" /&gt;\n  &lt;input-text label=\"Ticket Number\" spec=\"required regex:[A-Z]{2}[0-9]{4}\" /&gt;\n  &lt;input-text label=\"Your Message\" spec=\"required multiline\" /&gt;\n  &lt;submit-message&gt;\n    &lt;p&gt;Thanks for your submission! We normally respond in two business days.&lt;/p&gt;\n  &lt;/submit-message&gt;\n&lt;/input-form&gt;\n</code></pre>\n\n<p>This provides everything we (the developers) need to render a feedback form.</p>\n<ul>\n<li>We control the layout, so we’ll expand those <code>input-text</code> tags into multi-tag constructs to render each field.</li>\n<li>We can assume that things like the form <code>METHOD</code> and <code>ACTION</code> are standardized to the site, so we don’t need to ask for those.</li>\n<li>We can automatically obtain the URL/page from which they submitted. We could even develop some system where data from specific <code>META</code> tags in the <code>HEAD</code> are written to the form in hidden fields, meaning additional data can be injected into the form at the page templating level.</li>\n<li>We assume the form needs a submit button, so there’s no need to specify it.</li>\n<li>We can provide an “override default setting” model, where lots of stuff have default values that will be used if not provided. For example, I’m passing in <code>submitButtonText</code>, but that would certainly have a default value (“Submit Form”) that would be used if I didn’t feel like changing it.</li>\n<li>Inside the <code>input-text</code> tags, we can roll up validation (<code>required</code>, <code>&gt;4</code> meaning at least five characters) and UI (<code>multiline</code>) specification into the same <code>SPEC</code> attribute, so we have no need for another tag for <code>textarea</code>.</li>\n<li>We can derive all the field names from the <code>label</code>. Assuming we submit the form with client-side code, we could easily find the value of the the <code>label</code> for each input field via the <code>for</code> attribute, then serialize and submit that data as well, so the server would also get the “friendly name” of each input field.</li>\n</ul>\n<p>What we’ve done here is designed a specification language – two of them, actually.</p>\n<ol>\n<li>The combination of tags to specify the information we need to display and submit the form</li>\n<li>The embedded <code>spec</code> values which define validation and UI variations</li>\n</ol>\n<p>This is really, <em>really</em> fun. You start to ask interesting questions about what information you actually need explicitly, and what information you can derive. You’ll find situations where you can make vast changes based on fun combinations of explicit information and environmental data.</p>\n<p>It’s not hard to put together something that is unique to your specific situation and strikes a lovely combination among granularity, utility, and simplicity.</p>\n\n<h2>Postscript: Processing Markdown Client-Side</h2>\n<p>The original point of this post was about how to mix Markdown that’s processed server-side with Custom Elements that are processed client-side. As I noted, this is a common model, and the basis for all of the static site generation that happens these days.</p>\n<p>But, what if you just wanted to process the Markdown client-side as well?</p>\n<p>You certainly can. I’ve read that <a href=\"https://md-block.verou.me/\">md-block</a> is quite good for this.</p>\n<p>I don’t do it for a few reasons:</p>\n<ol>\n<li>I still have weird hang-ups about sending content source to the browser. Something about airing my dirty laundry? It’s not entirely rational, and I’ve spent a lot of time thinking about how it correlates to <a href=\"https://deanebarker.net/tech/blog/narratives/fourth-wall/\">breaking the fourth wall</a>.</li>\n<li>I wrote a bunch of <a href=\"https://github.com/xoofx/markdig/blob/master/src/Markdig/MarkdownExtensions.cs\">Markdig extensions</a> specific to my site and needs. I wrote these in C#, so I wouldn’t be able to port them to the browser (…I don’t think? <a href=\"https://developersvoice.com/blog/architecture/webassembly-wasm-and-net/\">WASM</a> might be able to do it?). Some client-side implementations might have extension frameworks too (here’s <a href=\"https://zerodevx.github.io/zero-md/?a=advanced-usage.md#extensibility\">an example of one in zero-md</a>), however my Markdown usage on this site extends back six years to when I was really a “C# or death” kind of guy.</li>\n</ol>\n\n<ol start=\"3\">\n<li>Some of the extensions I wrote require information from the server, which means rendering the Markdown in the browser would require multiple round-trips back to the server to get information, and I don’t love this.</li>\n</ol>\n<p>If you did want to render client-side, there’s also a bit of a perspective shift needed. Somewhat ironically in the context of this post, you’d need to surround your Markdown in a Custom Element (like the aforementioned <code>md-block</code> tag).</p>\n<p>This means that your Markdown rendering is a Custom Element on the same “level” as the Custom Elements we’ve been talking about above. The Custom Elements are not “embedded and ignored” by the Markdown engine, but rather they exist “alongside” the Markdown.</p>\n<p>Depending on the Markdown library, you might need to close that tag before opening the Custom Element.</p>\n<p>Like:</p>\n<pre><code>&lt;client-markdown&gt;\n  This is some ***Markdown!***\n&lt;/client-markdown&gt;\n&lt;subscribe-to /&gt;\n&lt;client-markdown&gt;\n  This is some more ***Markdown!***\n&lt;/client-markdown&gt;\n</code></pre>\n<p>Your need to do this probably depends on the library you use. I can’t generalize with any authority.</p>\n<p>In the end, your document is now fully an HTML document, not a Markdown document that <em>becomes</em> an HTML document. It’s a minor perspective shift, but might have some cascading effects on things I’ve written above.</p>\n<h2>Postscript: Processing Custom Elements Server-Side</h2>\n<p>You can also do the opposite of the above – if your server-side process is running in JavaScript (so, something like Node, Deno, or Bun), you can render the Custom Elements into expanded HTML on the server and send the HTML.</p>\n<p>I have never done this, but <a href=\"https://lit.dev/docs/ssr/overview/\">Lit supports it</a>. They even have a library that will re-hydrate the resulting HTML into “regular” Custom Elements when the page is finished loading.</p>\n<p>Clearly, unless you do that, you’re not going to get any interactivity, so this is mostly useful as a templating language (…I think? Honestly, I know very little about it, other than that it exists).</p>\n\n\n\n\n\n    \n\n\n\n    \n\n</article><p>\n            This is item <strong>#1</strong> in a sequence of <strong>364</strong> items.\n        </p></div>","textContent":"\n\n    \n\n\n\n  \n  \n\n\n\n\n\n    \n  \n\n    \n      \n    \n    \n      By Deane Barker\n    \n    •\n  \n\n  \n    August 9, 2025\n    •\n  \n  \n  \n\n\n\n\n\n\n\n    \n\n\n\n\n    \n\n\n    \n\n    \n\n\nI love Markdown. I write faster and more natively in it than any other format or tool.\nIf we zoom way out, here’s the most basic philosophy of Markdown: replace complicated stuff with simpler stuff.\nThat’s all it does, really. It replaces some tedious nested taggy stuff with way simpler stuff that makes more visual sense and is  faster to type. At its core, Markdown is really just a bunch of macros.\nThis website runs on 6,000-ish Markdown files. They’re processed on the server – meaning the Markdig library from .NET processes them, then sends back the resulting HTML. I’m all-in on Markdown, to the point where I wrote my own online editor for it.\nServer-side processing of Markdown is a pretty common model – most static site generators fundamentally do the same thing: they process the Markdown, turn it into HTML, and that gets sent to the server (via being written to files).\nOne of the philosophical points of Markdown is that you can mix it with HTML. Meaning, a Markdown parser is supposed to leave HTML alone – if a line of text looks like it has some tags, the parser should skip it.\nThis means you can do this:\nThis is some **Markdown!**\n\n<img src=\"yay.jpg\" />\n\nThis is some more ***Markdown!***\n\nAnd that should work fine. The first and last lines will be processed and transformed, and the middle line will be left alone and output as it’s written.\nThese were the original rules around inline HTML in Markdown:\n\nThe only restrictions are that block-level HTML elements […] must be separated from surrounding content by blank lines, and the start and end tags of the block should not be indented with tabs or spaces.\n\nI didn’t find the need for blank lines in the CommonMark spec, but just note that every Markdown processor might be a little different in this respect, so test.\nAnyway, we’ll likely get HTML that’s something like this out of the above Markdown.\n<p>This is some <strong>Markdown!</strong></p>\n<img src=\"yay.jpg\" />\n<p>This is some more <em><strong>Markdown!</strong></em></p>\n\nOur img tag is intact and has been left alone.\nThis is great, and helps you in some sticky situations. You can effectively “escape out” to HTML when you need to.\n\nHowever, this still leaves you with the problem where you might have a bunch of complicated, tedious HTML that forms a repeatable component of some kind that you don’t want to hand-manage and reproduce over and over. What if you want a Markdown-friendly way to represent a feedback form, or a tabbed UI, or a mortgage calculator, or something else way beyond the scope of text formatting.\nFor these situations, what you really want is to put a token or a placeholder in your Markdown, and have something else expand it later on into a larger, more complicated HTML construct.\nWhat you sort of need is… Markdown for More Complicated HTML™.\nEnter Custom Elements.\nThese have been around a long time. They tend to get lost behind all the attention paid to the big client-side frameworks like React, but the first public spec was published in 2013, finalized in 2016, and we’ve had broad browser support since 2018 or so.\n\nCustom Elements can do a lot, but a core function is that they divorce the source markup from what’s effectively output into the DOM.\nYou can write X in the markup; the Custom Element will output Y into the DOM.\nX is simple; Y is way more complicated.\nX is written by an editor; Y is written by logical processing.\nSo, considered at that level, Custom Elements can be used as… HTML macros.\nThis means that when you combine them with Markdown, you get a really neat synergy of features.\n\nMarkdown expands into text formatting\nCustom Elements (that the Markdown processor ignores) expands into more complicated stuff\n\nConsider this scenario: you have a blog post which is Part 1 of a series. You want to let people subscribe to be notified about Part 2, but that involves a little widget of some kind in the HTML. And for whatever reason, you have to put this between two paragraphs.\nWhat if you could do this:\nThis is some **Markdown!**\n\n<subscribe-to />\n\nThis is some more **Markdown!**\n\n(Remember, that middle line is HTML, so the Markdown processor will leave it alone.)\nThen, in the browser, that subscribe-to tag will expand into something like this:\n<div part=\"outer\">\n  <label part=\"label\">Want to know when Part 2 is published?</label>\n  <input part=\"input\" type=\"text\" name=\"email\" placeholder=\"Give us your email\">\n  <button part=\"button\" type=\"button\">Let me know!</button>\n</div>\n\nThis is exactly what Custom Elements can do.\nTo be clear, this is not a tutorial about Custom Elements in general – there’s a lot of depth there – but just a joyful discovery of what happens when we combine them with hand-written Markdown and come to the conclusion that both Custom Elements and Markdown sort of operate on the same principle from the perspective of the writer: they replace simpler stuff with more complex stuff.\nCustom Elements can just be simple tokens like the above (actually, what’s above is not quite valid, but more on that below), or you can expose configuration parameters to make them more usable in more situations:\nThis is some **Markdown!**\n\n<subscribe-to buttonText=\"Get me the details!\" />\n\nThis is some more **Markdown!**\n\nYou can even put stuff between Custom Element tags then use that in the processing and output. (You can go even further, by defining child tag structures and “slots” and all sorts of stuff that we won’t get into. Again, there’s so much depth there…)\nThis is some **Markdown!**\n\n<subscribe-to>\n\nWe'll use your email once, then delete it. _We promise!_\n\n</subscribe-to>\n\nThis is some more **Markdown!**\n\nGuess what happens to that line between the subscribe-to tags? Yes, it gets processed by the Markdown engine, because it’s not HTML – there’s no tag on that line. So the Markdown engine will process it, but leave the line above and below it alone, resulting in this:\n<subscribe-to>\n  <p>We'll use your email once, then delete it. <em>We promise!</em></p>\n</subscribe-to>\n\n\nDuring a bout of insomnia, I did some local testing of the general theory.\nI had Claude vibe-code a simple Node script that read a Markdown file which looked a lot like the samples above (Markdown paragraphs above and below, with a subscribe-to Custom Element in the middle). Then it processed the Markdown – Custom Element included – and output the result into a file.\nHere’s the Markdown source. There are two subscribe-to tags in there – one simple version, and one with a bunch of options I thought up.\nYou can see that when the browser encounters this – \n<subscribe-to />\n\n– it expands into HTML (in a shadow DOM) that ends up looking like this in the browser:\n\n\n\n\n\n\n\n\n\n\n\n\nOr this when you add some advanced options:\n\n\n\n\n\n\n\n\n\n\n\n\nHere’s the output file.\n(That’s raw HTML; you can view the source. Understand that it’s still subscribe-to in the source, but inspect the DOM and you can see what it effectively expands into. The JavaScript definition for the Custom Element is inline in the HTML doc. I used Lit as a base because it makes a lot of things so much easier.)\nI just love this.\nAn editor has Markdown acting as text macros, Custom Elements acting as HTML macros, and they can mix the two in the same file.  Simpler things become more complicated things. They can use Gruber’s “escape hatch” to handle infinitely complexity while being abstracted away from verbosity.\nThis opens some lovely possibilities for page, layout, and element complexity and functionality while retaining the “I wrote it in a simple text editor!” joy that made Markdown so awesome to start with.\nPostscript: Minor Technical Note\nI’ve been lying to you a little in this entire document. You actually can’t do this:\n<subscribe-to />\n\nCustom Elements cannot be self-closing (or a “void tag,” as they’re called). You technically have to do this:\n<subscribe-to></subscribe-to>\n\nThe self-closing version will work sometimes, kind of accidentally. Where it falls apart is when you put something between the tags, because the browser considers the self-closing tag as just the opening tag, which it then claims never closes.\nBut here’s how and why I started lying to you displaying the self-closing version.\nBecause – and stick with me here – here’s something else you can’t do: put your tag attributes on multiple lines.\n<subscribe-to\n  buttonText=\"I love getting email!\"\n  anotherAttribute=\"Another value\"\n>\n\nThis time, it’s not the browser that’s the problem – the browser is totally fine with you breaking out the attributes to their own lines. This time, it’s the Markdown engine. It looks at those middle lines and decides that they’re not HTML, not understanding that it’s logically part of the opening tag. This means that – you guessed it – the Markdown engine tries to process it and everything falls apart.\n(As noted above, this might vary a bit between Markdown engines. Claude picked Marked for this POC.)\nI didn’t like that I couldn’t do this. I wanted to be able to break out all my attributes on their own lines.\nTo solve this, I had Claude vibe up a simple (?) Markdown pre-processor. So before the source Markdown got fed into Marked, some code in the Node app “fixes” the tag – reassembles it all back on the same line.\nAnd, while I was doing that, I also “fixed” the self-closing tag issue. If the code detected a self-closing tag that contained a dash (which Custom Elements must), it changed it to an explicitly closed tag. That’s why I showed you the self-closing tag. But know that by the time it got to the Markdown engine, it was explicitly closed.\nIt was just cleaner and less confusing while I was early in the explanation.\nHere’s the source of the Node app with the preprocessor in a (pretty gross-looking) function called preprocessMarkdown.\n(Full disclosure: I didn’t even bother to check this. It was just a POC, so I had Claude write it. I could have written it myself, but didn’t want to put in the effort for something with no larger goal.)\nPostscript: Fun and Madness with Markdown Preprocessing\nOnce you crack open the door of Markdown pre-processing, you can be sorely tempted to head further down that road. For instance, if you don’t like the idea of raw HTML in your Markdown, you could essentially write your own mini-language.\nFor example, something like:\n@:subscribe-to\n buttonText: I love email!\n placeHolder: Give us your email!\n\nAll you have to do is write some preprocessing code that detects that construct and forms it into the Custom Element tag.\n\nIs that “better” than raw HTML? I don’t know… maybe?\nThe looming problem is that this is just one simplistic Custom Element example. When you get into more advanced features like child tag structures and slots and such, you’d probably end up re-interpreting and re-implementing way more of the HTML spec than you want to.\nI predict there will be a point where you regret trying to do this. Pre-processing and the initial excitement of a domain-specific language is a siren that might lead you to your doom.\n(I swear, I have never tried to do something this foolish… I swear…)\nPostscript: Fun with Language Design\nWhen you realize that Custom Elements effectively abstract writing HTML away from deeper logical programming, you realize that designing the logical interface of your Custom Elements is a fun exercise in language design.\nThe basic principle becomes: don’t ask for anything you don’t absolutely need. Do as much work as possible for your editors in code. Require them to provide as little information as possible.\nIf we want to embed a feedback form, for instance, we could do something like this:\n<input-form submitButtonText=\"Send message!\">\n  <input-text label=\"Your Name\" spec=\"required >4\" />\n  <input-text label=\"Your Email\" spec=\"required email\" />\n  <input-text label=\"Ticket Number\" spec=\"required regex:[A-Z]{2}[0-9]{4}\" />\n  <input-text label=\"Your Message\" spec=\"required multiline\" />\n  <submit-message>\n    <p>Thanks for your submission! We normally respond in two business days.</p>\n  </submit-message>\n</input-form>\n\n\nThis provides everything we (the developers) need to render a feedback form.\n\nWe control the layout, so we’ll expand those input-text tags into multi-tag constructs to render each field.\nWe can assume that things like the form METHOD and ACTION are standardized to the site, so we don’t need to ask for those.\nWe can automatically obtain the URL/page from which they submitted. We could even develop some system where data from specific META tags in the HEAD are written to the form in hidden fields, meaning additional data can be injected into the form at the page templating level.\nWe assume the form needs a submit button, so there’s no need to specify it.\nWe can provide an “override default setting” model, where lots of stuff have default values that will be used if not provided. For example, I’m passing in submitButtonText, but that would certainly have a default value (“Submit Form”) that would be used if I didn’t feel like changing it.\nInside the input-text tags, we can roll up validation (required, >4 meaning at least five characters) and UI (multiline) specification into the same SPEC attribute, so we have no need for another tag for textarea.\nWe can derive all the field names from the label. Assuming we submit the form with client-side code, we could easily find the value of the the label for each input field via the for attribute, then serialize and submit that data as well, so the server would also get the “friendly name” of each input field.\n\nWhat we’ve done here is designed a specification language – two of them, actually.\n\nThe combination of tags to specify the information we need to display and submit the form\nThe embedded spec values which define validation and UI variations\n\nThis is really, really fun. You start to ask interesting questions about what information you actually need explicitly, and what information you can derive. You’ll find situations where you can make vast changes based on fun combinations of explicit information and environmental data.\nIt’s not hard to put together something that is unique to your specific situation and strikes a lovely combination among granularity, utility, and simplicity.\n\nPostscript: Processing Markdown Client-Side\nThe original point of this post was about how to mix Markdown that’s processed server-side with Custom Elements that are processed client-side. As I noted, this is a common model, and the basis for all of the static site generation that happens these days.\nBut, what if you just wanted to process the Markdown client-side as well?\nYou certainly can. I’ve read that md-block is quite good for this.\nI don’t do it for a few reasons:\n\nI still have weird hang-ups about sending content source to the browser. Something about airing my dirty laundry? It’s not entirely rational, and I’ve spent a lot of time thinking about how it correlates to breaking the fourth wall.\nI wrote a bunch of Markdig extensions specific to my site and needs. I wrote these in C#, so I wouldn’t be able to port them to the browser (…I don’t think? WASM might be able to do it?). Some client-side implementations might have extension frameworks too (here’s an example of one in zero-md), however my Markdown usage on this site extends back six years to when I was really a “C# or death” kind of guy.\n\n\n\nSome of the extensions I wrote require information from the server, which means rendering the Markdown in the browser would require multiple round-trips back to the server to get information, and I don’t love this.\n\nIf you did want to render client-side, there’s also a bit of a perspective shift needed. Somewhat ironically in the context of this post, you’d need to surround your Markdown in a Custom Element (like the aforementioned md-block tag).\nThis means that your Markdown rendering is a Custom Element on the same “level” as the Custom Elements we’ve been talking about above. The Custom Elements are not “embedded and ignored” by the Markdown engine, but rather they exist “alongside” the Markdown.\nDepending on the Markdown library, you might need to close that tag before opening the Custom Element.\nLike:\n<client-markdown>\n  This is some ***Markdown!***\n</client-markdown>\n<subscribe-to />\n<client-markdown>\n  This is some more ***Markdown!***\n</client-markdown>\n\nYour need to do this probably depends on the library you use. I can’t generalize with any authority.\nIn the end, your document is now fully an HTML document, not a Markdown document that becomes an HTML document. It’s a minor perspective shift, but might have some cascading effects on things I’ve written above.\nPostscript: Processing Custom Elements Server-Side\nYou can also do the opposite of the above – if your server-side process is running in JavaScript (so, something like Node, Deno, or Bun), you can render the Custom Elements into expanded HTML on the server and send the HTML.\nI have never done this, but Lit supports it. They even have a library that will re-hydrate the resulting HTML into “regular” Custom Elements when the page is finished loading.\nClearly, unless you do that, you’re not going to get any interactivity, so this is mostly useful as a templating language (…I think? Honestly, I know very little about it, other than that it exists).\n\n\n\n\n\n    \n\n\n\n    \n\n\n            This is item #1 in a sequence of 364 items.\n        ","length":17510,"excerpt":"I love Markdown. I write faster and more natively in it than any other format or tool. If we zoom way out, here’s the most basic philosophy of Markdown: replace complicated stuff with simpler stuff. That’s all it does, really. It replaces some tedious nested taggy stuff with way simpler stuff that…","publishedTime":"2025-08-09 05:00:00Z","url":"https://deanebarker.net/tech/blog/custom-elements-markdown/"}