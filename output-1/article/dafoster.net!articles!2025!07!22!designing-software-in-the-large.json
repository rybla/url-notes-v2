{"title":"Designing Software in the Large","byline":"David Foster","lang":"en","content":"<div id=\"readability-page-1\" class=\"page\"><div>\n    \n    \n    \n    <p><a href=\"https://www.amazon.com/Philosophy-Software-Design-2nd/dp/173210221X/\">A Philosophy of Software Design</a> is my favorite book I’ve read to date about designing large long-lived maintainable software programs. Here’s what I learned:</p>\n\n<h2>Complexity</h2>\n\n<p><strong>Complexity</strong> is anything related to the structure of a software system that makes it hard to understand &amp; modify the system.</p>\n\n<ul>\n<li><p>Symptoms of complexity:</p>\n\n<ul>\n<li><strong>Change Amplification</strong> - A seemingly simple change requires code modifications in many different places.</li>\n<li><strong>High Cognitive Load</strong> - High amount of information a developer needs to know to complete a task.</li>\n<li><strong>Unknown Unknowns</strong> - When it is not obvious which pieces of code must be modified to complete a task, or what information a developer must have to carry out the task successfully.</li>\n</ul>\n</li>\n<li><p>Causes of complexity:</p>\n\n<ul>\n<li><strong>Dependencies</strong> - A dependency exists when a given piece of code cannot be understood and modified in isolation; the code relates in some way to other code.</li>\n<li><strong>Obscurity</strong> - Obscurity occurs when important information is not obvious.</li>\n</ul>\n</li>\n</ul>\n\n\n<p><a href=\"https://dafoster.net/assets/2025/designing-software-in-the-large/section0.svg\"><img src=\"https://dafoster.net/assets/2025/designing-software-in-the-large/section0.svg\" alt=\"A concept map diagram showing symptoms and causes of complexity, and how they related to each other\"></a></p>\n\n<p>To keep a software system maintainable, you must strive to keep the complexity of the system low as you &amp; others make changes to it.</p>\n\n<h3>The big picture</h3>\n\n<p>Concepts related to complexity, which the remaining sections of this article will zoom in on:</p>\n\n<p><a href=\"https://dafoster.net/assets/2025/designing-software-in-the-large/section2.svg\"><img src=\"https://dafoster.net/assets/2025/designing-software-in-the-large/section2.svg\"></a></p>\n\n<h2>Dependencies: A Cause of Complexity</h2>\n\n<p>A <strong>dependency</strong> exists when a given piece of code cannot be understood in isolation; the code relates in some way to other code. Numerous and strong dependencies between modules of a system make it difficult to change one module without changing others (Change Amplification) and make it difficult to understand modules in isolation (High Cognitive Load).</p>\n\n<p>Key contributors to dependency-complexity are:</p>\n\n<ul>\n<li><strong>Duplication</strong> - Duplication occurs when the same knowledge is used in multiple places. This can be direct repetition of the same piece of code appearing in multiple places. Or it can be more subtle, such as multiple classes understanding the details of the same file format or network protocol.</li>\n<li><strong>Exceptions</strong> - An exception is a particularly complex element of an interface which can propagate not just from a method to its direct caller but also to higher level callers (and their interfaces).</li>\n<li><strong>Inheritance</strong> - Implementation inheritance in object-oriented systems creates dependencies between the parent class and each of its subclasses.</li>\n<li><strong>Temporal Decomposition</strong> - A system exhibits temporal decomposition when its structure corresponds to the time order in which operations will occur.</li>\n</ul>\n\n\n<p>The opposite of dependency-complexity is <strong>cohesive code</strong>, created primarily by focusing on designing <strong>deep modules</strong>.</p>\n\n<p><a href=\"https://dafoster.net/assets/2025/designing-software-in-the-large/section1.svg\"><img src=\"https://dafoster.net/assets/2025/designing-software-in-the-large/section1.svg\"></a></p>\n\n<p><strong>Deep modules</strong> allow a lot of functionality to be accessed through a small interface:</p>\n\n<p><a href=\"https://dafoster.net/assets/2025/designing-software-in-the-large/deep-and-shallow-modules.svg\"><img src=\"https://dafoster.net/assets/2025/designing-software-in-the-large/deep-and-shallow-modules.svg\"></a></p>\n\n<p>Keeping module interfaces small lowers the number and strength of dependencies between modules, resulting in lower overall system complexity:</p>\n\n<p><a href=\"https://dafoster.net/assets/2017/abstraction-and-encapsulation/complexity_comparison.png\"><img alt=\"Complexity with and without abstractions\" src=\"https://dafoster.net/assets/2017/abstraction-and-encapsulation/complexity_comparison.png\"></a></p>\n\n<p>Chapters 4-9 of the book are related to techniques for forming deeper modules. My article <a href=\"https://dafoster.net/articles/2017/03/25/how-to-design-large-programs-with-abstraction-and-encapsulation/\">How to Design Large Programs with Abstraction and Encapsulation</a> also discusses deep modules in the context of encapsulation &amp; abstraction.</p>\n\n<h2>Obscurity: A Cause of Complexity</h2>\n\n<p><strong>Obscurity</strong> occurs when important information is not obvious.</p>\n\n<p>Obscurity creates Unknown Unknowns and contributes to High Cognitive Load:</p>\n\n<p><a href=\"https://dafoster.net/assets/2025/designing-software-in-the-large/section3.svg\"><img src=\"https://dafoster.net/assets/2025/designing-software-in-the-large/section3.svg\"></a></p>\n\n<p>Key contributors to obscurity:</p>\n\n<ul>\n<li><strong>Vague Names</strong></li>\n<li><strong>Inconsistency</strong></li>\n<li><strong>Inadequate Documentation</strong>.</li>\n</ul>\n\n\n<p>Smaller contributors to obscurity:</p>\n\n<ul>\n<li>indirection via <strong>listeners</strong></li>\n<li>indirection via <strong>polymorphism</strong></li>\n<li>using <strong>generic containers to hold structured data</strong></li>\n</ul>\n\n\n<p>The opposite of obscurity is <strong>obvious code</strong>. Obvious code</p>\n\n<ul>\n<li>uses <strong>precise names</strong>,</li>\n<li>is <strong>consistent</strong>,</li>\n<li>is <strong>well-documented</strong>, and</li>\n<li>makes good use of <strong>whitespace</strong>.</li>\n</ul>\n\n\n<p><a href=\"https://dafoster.net/assets/2025/designing-software-in-the-large/section4.svg\"><img src=\"https://dafoster.net/assets/2025/designing-software-in-the-large/section4.svg\"></a></p>\n\n<p>There are many techniques for creating <strong>consistency</strong> in code:</p>\n\n<ul>\n<li><p><strong>Consistent use of names</strong>, <strong>consistent code style</strong>, and <strong>consistent implementation patterns</strong> are hallmarks of consistency in general.</p></li>\n<li><p>Tools such as <strong>autoformatters</strong>, <strong>linters</strong>, and <strong>automated consistency tests</strong> are great for enforcing consistency.</p></li>\n<li><p><strong>Documentation</strong> of conventions can be captured in <strong>coding style guides</strong> and through references to documented <strong>design patterns</strong>.</p></li>\n</ul>\n\n\n<p><a href=\"https://dafoster.net/assets/2025/designing-software-in-the-large/section5.svg\"><img src=\"https://dafoster.net/assets/2025/designing-software-in-the-large/section5.svg\"></a></p>\n\n<h2>Strategic vs. Tactical Mindset</h2>\n\n<p><img id=\"tactical-tornado-img\" src=\"https://dafoster.net/assets/2025/designing-software-in-the-large/tactical-tornado.svg\"></p>\n\n<p>Complexity accumulates naturally in a software system if left unchecked.</p>\n\n<p>And once complexity has accumulated it is hard to eliminate.</p>\n\n<p>Therefore the book recommends taking a “zero-tolerance” stance toward the incremental introduction of complexity.</p>\n\n<p>Specifically, it advocates taking a <strong>strategic approach</strong> to programming tasks, where you intentionally invest time to produce clean designs and fix problems, in addition to getting new features working.</p>\n\n<p>Many programmers, by contrast, take a purely <strong>tactical approach</strong> that focuses <em>only</em> on getting new features working, disregarding the long-term costs of adding incremental complexity and other forms of cutting corners.</p>\n\n<h2>Takeaway</h2>\n\n<p><strong>Working code (alone) is not enough.</strong></p>\n\n<p>To keep a software system maintainable, you must strive to keep the complexity of the system low as you &amp; others make changes to it.</p>\n\n  </div></div>","textContent":"\n    \n    \n    \n    A Philosophy of Software Design is my favorite book I’ve read to date about designing large long-lived maintainable software programs. Here’s what I learned:\n\nComplexity\n\nComplexity is anything related to the structure of a software system that makes it hard to understand & modify the system.\n\n\nSymptoms of complexity:\n\n\nChange Amplification - A seemingly simple change requires code modifications in many different places.\nHigh Cognitive Load - High amount of information a developer needs to know to complete a task.\nUnknown Unknowns - When it is not obvious which pieces of code must be modified to complete a task, or what information a developer must have to carry out the task successfully.\n\n\nCauses of complexity:\n\n\nDependencies - A dependency exists when a given piece of code cannot be understood and modified in isolation; the code relates in some way to other code.\nObscurity - Obscurity occurs when important information is not obvious.\n\n\n\n\n\n\n\nTo keep a software system maintainable, you must strive to keep the complexity of the system low as you & others make changes to it.\n\nThe big picture\n\nConcepts related to complexity, which the remaining sections of this article will zoom in on:\n\n\n\nDependencies: A Cause of Complexity\n\nA dependency exists when a given piece of code cannot be understood in isolation; the code relates in some way to other code. Numerous and strong dependencies between modules of a system make it difficult to change one module without changing others (Change Amplification) and make it difficult to understand modules in isolation (High Cognitive Load).\n\nKey contributors to dependency-complexity are:\n\n\nDuplication - Duplication occurs when the same knowledge is used in multiple places. This can be direct repetition of the same piece of code appearing in multiple places. Or it can be more subtle, such as multiple classes understanding the details of the same file format or network protocol.\nExceptions - An exception is a particularly complex element of an interface which can propagate not just from a method to its direct caller but also to higher level callers (and their interfaces).\nInheritance - Implementation inheritance in object-oriented systems creates dependencies between the parent class and each of its subclasses.\nTemporal Decomposition - A system exhibits temporal decomposition when its structure corresponds to the time order in which operations will occur.\n\n\n\nThe opposite of dependency-complexity is cohesive code, created primarily by focusing on designing deep modules.\n\n\n\nDeep modules allow a lot of functionality to be accessed through a small interface:\n\n\n\nKeeping module interfaces small lowers the number and strength of dependencies between modules, resulting in lower overall system complexity:\n\n\n\nChapters 4-9 of the book are related to techniques for forming deeper modules. My article How to Design Large Programs with Abstraction and Encapsulation also discusses deep modules in the context of encapsulation & abstraction.\n\nObscurity: A Cause of Complexity\n\nObscurity occurs when important information is not obvious.\n\nObscurity creates Unknown Unknowns and contributes to High Cognitive Load:\n\n\n\nKey contributors to obscurity:\n\n\nVague Names\nInconsistency\nInadequate Documentation.\n\n\n\nSmaller contributors to obscurity:\n\n\nindirection via listeners\nindirection via polymorphism\nusing generic containers to hold structured data\n\n\n\nThe opposite of obscurity is obvious code. Obvious code\n\n\nuses precise names,\nis consistent,\nis well-documented, and\nmakes good use of whitespace.\n\n\n\n\n\nThere are many techniques for creating consistency in code:\n\n\nConsistent use of names, consistent code style, and consistent implementation patterns are hallmarks of consistency in general.\nTools such as autoformatters, linters, and automated consistency tests are great for enforcing consistency.\nDocumentation of conventions can be captured in coding style guides and through references to documented design patterns.\n\n\n\n\n\nStrategic vs. Tactical Mindset\n\n\n\nComplexity accumulates naturally in a software system if left unchecked.\n\nAnd once complexity has accumulated it is hard to eliminate.\n\nTherefore the book recommends taking a “zero-tolerance” stance toward the incremental introduction of complexity.\n\nSpecifically, it advocates taking a strategic approach to programming tasks, where you intentionally invest time to produce clean designs and fix problems, in addition to getting new features working.\n\nMany programmers, by contrast, take a purely tactical approach that focuses only on getting new features working, disregarding the long-term costs of adding incremental complexity and other forms of cutting corners.\n\nTakeaway\n\nWorking code (alone) is not enough.\n\nTo keep a software system maintainable, you must strive to keep the complexity of the system low as you & others make changes to it.\n\n  ","length":4894,"excerpt":"A Philosophy of Software Design is my favorite book I’ve read to date about designing large long-lived maintainable software programs. Here’s what I learned:","siteName":"David Foster","publishedTime":"2025-07-22T00:00:00+00:00","url":"https://dafoster.net/articles/2025/07/22/designing-software-in-the-large/"}