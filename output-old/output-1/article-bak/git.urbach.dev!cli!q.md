{"title":"q","byline":"cli","dir":null,"lang":"en-US","content":"<div id=\"readability-page-1\" class=\"page\"><div id=\"readme\">\n\t\t\t\n\t\t\t\t<div>\n\t<p><img src=\"https://git.urbach.dev/cli/q/media/branch/main/docs/logo.svg\" width=\"90\" alt=\"q logo\"></p><h2>The Q Programming Language</h2>\n\t<p>Q is a minimal, dependency-free programming language and compiler targeting x86-64 and arm64 with ultra-fast builds and tiny binaries.</p>\n</div>\n<h2 id=\"user-content-features\" dir=\"auto\">Features</h2>\n<ul dir=\"auto\">\n<li>High performance (<code>ssa</code> and <code>asm</code> optimizations)</li>\n<li>Fast compilation (&lt;100 Œºs for simple programs)</li>\n<li>Tiny executables (\"Hello World\" is ~600 bytes)</li>\n<li>Multiple platforms (Linux, Mac and Windows)</li>\n<li>Zero dependencies (no llvm, no libc)</li>\n</ul>\n<h2 id=\"user-content-installation\" dir=\"auto\">Installation</h2>\n\n<p dir=\"auto\">Build from source:</p>\n<pre><code>git clone https://git.urbach.dev/cli/q\n<span>cd</span> q\ngo build\n</code></pre><p dir=\"auto\">Install via symlink:</p>\n<pre><code>ln -s <span>$PWD</span>/q ~/.local/bin/q\n</code></pre><h2 id=\"user-content-usage\" dir=\"auto\">Usage</h2>\n<p dir=\"auto\">Run <code>hello</code> example:</p>\n<pre><code>q examples/hello\n</code></pre><p dir=\"auto\">Build an executable:</p>\n<pre><code>q build examples/hello\n</code></pre><p dir=\"auto\">Build for another architecture:</p>\n<pre><code>q build examples/hello --arch arm\nq build examples/hello --arch x86\n</code></pre><p dir=\"auto\">Build for another operating system:</p>\n<pre><code>q build examples/hello --os linux\nq build examples/hello --os mac\nq build examples/hello --os windows\n</code></pre><p dir=\"auto\">Build with verbose output:</p>\n<pre><code>q build examples/hello --verbose\n</code></pre><h2 id=\"user-content-language-specification\" dir=\"auto\">Language specification</h2>\n<p dir=\"auto\">The work is currently being focused on the correctness of the compiler and the proper code generation for all architectures and operating systems.</p>\n<p dir=\"auto\">The language syntax is highly volatile at this point but you can take a look at the <a href=\"https://git.urbach.dev/cli/q/src/branch/main/examples\" rel=\"nofollow\">examples</a> or the <a href=\"https://git.urbach.dev/cli/q/src/branch/main/tests\" rel=\"nofollow\">tests</a> to get a perspective on the current status.</p>\n<p dir=\"auto\">Documentation for all language features will follow once the core systems are stable.</p>\n<h2 id=\"user-content-source-overview\" dir=\"auto\">Source overview</h2>\n<p dir=\"auto\">This section is for contributors who want a high-level overview of the source code structure.</p>\n<h3 id=\"user-content-packages\" dir=\"auto\">Packages</h3>\n<ul dir=\"auto\">\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/arm\" rel=\"nofollow\">arm</a> - arm64 architecture</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/asm\" rel=\"nofollow\">asm</a> - Generic assembler</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/ast\" rel=\"nofollow\">ast</a> - Abstract syntax tree</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/cli\" rel=\"nofollow\">cli</a> - Command line interface</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/codegen\" rel=\"nofollow\">codegen</a> - SSA to assembly code generation</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/compiler\" rel=\"nofollow\">compiler</a> - Compiler frontend</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/config\" rel=\"nofollow\">config</a> - Build configuration</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/core\" rel=\"nofollow\">core</a> - Defines <code>Function</code> and compiles tokens to SSA</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/cpu\" rel=\"nofollow\">cpu</a> - Types to represent a generic CPU</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/data\" rel=\"nofollow\">data</a> - Data container that can re-use existing data</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/dll\" rel=\"nofollow\">dll</a> - DLL support for Windows systems</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/elf\" rel=\"nofollow\">elf</a> - ELF format for Linux executables</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/errors\" rel=\"nofollow\">errors</a> - Error handling that reports lines and columns</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/exe\" rel=\"nofollow\">exe</a> - Generic executable format to calculate section offsets</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/expression\" rel=\"nofollow\">expression</a> - Expression parser generating trees</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/fs\" rel=\"nofollow\">fs</a> - File system access</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/global\" rel=\"nofollow\">global</a> - Global variables like the working directory</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/linker\" rel=\"nofollow\">linker</a> - Frontend for generating executable files</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/macho\" rel=\"nofollow\">macho</a> - Mach-O format for Mac executables</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/memfile\" rel=\"nofollow\">memfile</a> - Memory backed file descriptors</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/pe\" rel=\"nofollow\">pe</a> - PE format for Windows executables</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/scanner\" rel=\"nofollow\">scanner</a> - Scanner that parses top-level instructions</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/set\" rel=\"nofollow\">set</a> - Generic set implementation</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/sizeof\" rel=\"nofollow\">sizeof</a> - Calculates the byte size of numbers</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/ssa\" rel=\"nofollow\">ssa</a> - Static single assignment types</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/token\" rel=\"nofollow\">token</a> - Tokenizer</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/types\" rel=\"nofollow\">types</a> - Type system</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/verbose\" rel=\"nofollow\">verbose</a> - Verbose output</li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/x86\" rel=\"nofollow\">x86</a> - x86-64 architecture</li>\n</ul>\n<h3 id=\"user-content-typical-flow\" dir=\"auto\">Typical flow</h3>\n<ol dir=\"auto\">\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/main.go\" rel=\"nofollow\">main</a></li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/cli/Exec.go\" rel=\"nofollow\">cli.Exec</a></li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/compiler/Compile.go\" rel=\"nofollow\">compiler.Compile</a></li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/scanner/Scan.go\" rel=\"nofollow\">scanner.Scan</a></li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/core/Compile.go\" rel=\"nofollow\">core.Compile</a></li>\n<li><a href=\"https://git.urbach.dev/cli/q/src/branch/main/src/linker/Write.go\" rel=\"nofollow\">linker.Write</a></li>\n</ol>\n<h2 id=\"user-content-faq\" dir=\"auto\">FAQ</h2>\n<h3 id=\"user-content-how-tiny-is-a-hello-world\" dir=\"auto\">How tiny is a Hello World?</h3>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>arm64</th>\n<th>x86-64</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span aria-label=\"penguin\" data-alias=\"penguin\">üêß</span> Linux</td>\n<td>646 bytes</td>\n<td>582 bytes</td>\n</tr>\n<tr>\n<td><span aria-label=\"green apple\" data-alias=\"green_apple\">üçè</span> Mac</td>\n<td>49.3 KiB</td>\n<td>12.5 KiB</td>\n</tr>\n<tr>\n<td><span aria-label=\"window\" data-alias=\"window\">ü™ü</span> Windows</td>\n<td>1.7 KiB</td>\n<td>1.7 KiB</td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">This table often raises the question why Mac builds are so huge compared to the rest. The answer is in <a href=\"https://github.com/apple-oss-distributions/xnu/blob/e3723e1f17661b24996789d8afc084c0c3303b26/bsd/kern/mach_loader.c#L2021-L2027\" rel=\"nofollow\">these few lines</a> of their kernel code. None of the other operating systems force you to page-align sections on disk. In practice, however, it's not as bad as it sounds because the padding is a zero-filled area that barely consumes any disk space in <a href=\"https://en.wikipedia.org/wiki/Sparse_file\" rel=\"nofollow\">sparse files</a>.</p>\n<h3 id=\"user-content-which-platforms-are-supported\" dir=\"auto\">Which platforms are supported?</h3>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>arm64</th>\n<th>x86-64</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><span aria-label=\"penguin\" data-alias=\"penguin\">üêß</span> Linux</td>\n<td><span aria-label=\"check mark\" data-alias=\"heavy_check_mark\">‚úîÔ∏è</span></td>\n<td><span aria-label=\"check mark\" data-alias=\"heavy_check_mark\">‚úîÔ∏è</span></td>\n</tr>\n<tr>\n<td><span aria-label=\"green apple\" data-alias=\"green_apple\">üçè</span> Mac</td>\n<td><span aria-label=\"check mark\" data-alias=\"heavy_check_mark\">‚úîÔ∏è</span>*</td>\n<td><span aria-label=\"check mark\" data-alias=\"heavy_check_mark\">‚úîÔ∏è</span></td>\n</tr>\n<tr>\n<td><span aria-label=\"window\" data-alias=\"window\">ü™ü</span> Windows</td>\n<td><span aria-label=\"check mark\" data-alias=\"heavy_check_mark\">‚úîÔ∏è</span>*</td>\n<td><span aria-label=\"check mark\" data-alias=\"heavy_check_mark\">‚úîÔ∏è</span></td>\n</tr>\n</tbody>\n</table>\n<p dir=\"auto\">Those marked with a star need testing. Please contact me if you have a machine with the marked architectures.</p>\n<h3 id=\"user-content-how-is-the-assembly-code-quality\" dir=\"auto\">How is the assembly code quality?</h3>\n<p dir=\"auto\">The backend uses an SSA based IR which is also used by well established compilers like <code>gcc</code>, <code>go</code> and <code>llvm</code>. SSA makes it trivial to apply lots of common optimization passes to it. As such, the quality of the generated assembly is fairly high despite the young age of the project.</p>\n<h3 id=\"user-content-which-security-features-are-supported\" dir=\"auto\">Which security features are supported?</h3>\n<h4 id=\"user-content-pie\" dir=\"auto\">PIE</h4>\n<p dir=\"auto\">All executables are built as position independent executables supporting a dynamic base address.</p>\n<h4 id=\"user-content-w-x\" dir=\"auto\">W^X</h4>\n<p dir=\"auto\">All memory pages are loaded with either execute or write permissions but never with both. Constant data is read-only.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Read</th>\n<th>Execute</th>\n<th>Write</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Code</td>\n<td><span aria-label=\"check mark\" data-alias=\"heavy_check_mark\">‚úîÔ∏è</span></td>\n<td><span aria-label=\"check mark\" data-alias=\"heavy_check_mark\">‚úîÔ∏è</span></td>\n<td><span aria-label=\"cross mark\" data-alias=\"x\">‚ùå</span></td>\n</tr>\n<tr>\n<td>Data</td>\n<td><span aria-label=\"check mark\" data-alias=\"heavy_check_mark\">‚úîÔ∏è</span></td>\n<td><span aria-label=\"cross mark\" data-alias=\"x\">‚ùå</span></td>\n<td><span aria-label=\"cross mark\" data-alias=\"x\">‚ùå</span></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"user-content-how-do-i-use-it-for-scripting\" dir=\"auto\">How do I use it for scripting?</h3>\n<p dir=\"auto\">The compiler is actually so fast that it's possible to compile an entire script within microseconds.</p>\n<pre><code>#!/usr/bin/env q\n\nimport io\n\nmain() {\n\tio.write(\"Hello\\n\")\n}\n</code></pre><p dir=\"auto\">Create a file with the contents above and add permissions via <code>chmod +x</code>. Now you can execute it from anywhere. The generated machine code runs directly from RAM if the OS supports it.</p>\n<h3 id=\"user-content-any-editor-extensions\" dir=\"auto\">Any editor extensions?</h3>\n<p dir=\"auto\">There is one for VS Code but is only has syntax highlighting so far. You can clone the <a href=\"https://git.urbach.dev/extra/vscode-q\" rel=\"nofollow\">vscode-q</a> repository into your extensions folder.</p>\n<p dir=\"auto\">Neovim support is planned.</p>\n<h3 id=\"user-content-how-do-i-pronounce-the-name\" dir=\"auto\">How do I pronounce the name?</h3>\n<p dir=\"auto\">/<span data-tooltip-content=\"Àà [U+02C8] can be confused with ` [U+0060]\"><span>Àà</span></span>kju<span data-tooltip-content=\"Àê [U+02D0] can be confused with : [U+003A]\"><span>Àê</span></span>/ just like <code>q</code> in the English alphabet.</p>\n<h2 id=\"user-content-faq-contributors\" dir=\"auto\">FAQ: Contributors</h2>\n<h3 id=\"user-content-how-do-i-run-the-test-suite\" dir=\"auto\">How do I run the test suite?</h3>\n<p dir=\"auto\">Run all tests:</p>\n<pre><code>go run gotest.tools/gotestsum@latest\n</code></pre><p dir=\"auto\">Generate coverage:</p>\n<pre><code>go <span>test</span> -coverpkg<span>=</span>./... -coverprofile<span>=</span>cover.out ./...\n</code></pre><p dir=\"auto\">View coverage:</p>\n<pre><code>go tool cover -func cover.out\ngo tool cover -html cover.out\n</code></pre><h3 id=\"user-content-how-do-i-run-the-benchmarks\" dir=\"auto\">How do I run the benchmarks?</h3>\n<p dir=\"auto\">Run compiler benchmarks:</p>\n<pre><code>go <span>test</span> ./tests -run<span>=</span><span>'^$'</span> -bench<span>=</span>. -benchmem\n</code></pre><p dir=\"auto\">Run compiler benchmarks in single-threaded mode:</p>\n<pre><code><span>GOMAXPROCS</span><span>=</span><span>1</span> go <span>test</span> ./tests -run <span>'^$'</span> -bench . -benchmem\n</code></pre><p dir=\"auto\">Generate profiling data:</p>\n<pre><code>go <span>test</span> ./tests -run<span>=</span><span>'^$'</span> -bench<span>=</span>. -benchmem -cpuprofile cpu.out -memprofile mem.out\n</code></pre><p dir=\"auto\">View profiling data:</p>\n<pre><code>go tool pprof --nodefraction<span>=</span>0.1 -http<span>=</span>:8080 ./cpu.out\ngo tool pprof --nodefraction<span>=</span>0.1 -http<span>=</span>:8080 ./mem.out\n</code></pre><h3 id=\"user-content-is-there-an-irc-channel\" dir=\"auto\">Is there an IRC channel?</h3>\n<p dir=\"auto\"><a href=\"ircs://irc.urbach.dev:6697/#q\" rel=\"nofollow\">#q</a> on <a href=\"https://irc.urbach.dev/\" rel=\"nofollow\">irc.urbach.dev</a>.</p>\n<h2 id=\"user-content-license\" dir=\"auto\">License</h2>\n<p dir=\"auto\">Please see the <a href=\"https://urbach.dev/license\" rel=\"nofollow\">license documentation</a>.</p>\n<h2 id=\"user-content-copyright\" dir=\"auto\">Copyright</h2>\n<p dir=\"auto\">¬© 2025 Eduard Urbach</p>\n\n\t\t\t\n\t\t</div></div>","textContent":"\n\t\t\t\n\t\t\t\t\n\tThe Q Programming Language\n\tQ is a minimal, dependency-free programming language and compiler targeting x86-64 and arm64 with ultra-fast builds and tiny binaries.\n\nFeatures\n\nHigh performance (ssa and asm optimizations)\nFast compilation (<100 Œºs for simple programs)\nTiny executables (\"Hello World\" is ~600 bytes)\nMultiple platforms (Linux, Mac and Windows)\nZero dependencies (no llvm, no libc)\n\nInstallation\n\nBuild from source:\ngit clone https://git.urbach.dev/cli/q\ncd q\ngo build\nInstall via symlink:\nln -s $PWD/q ~/.local/bin/q\nUsage\nRun hello example:\nq examples/hello\nBuild an executable:\nq build examples/hello\nBuild for another architecture:\nq build examples/hello --arch arm\nq build examples/hello --arch x86\nBuild for another operating system:\nq build examples/hello --os linux\nq build examples/hello --os mac\nq build examples/hello --os windows\nBuild with verbose output:\nq build examples/hello --verbose\nLanguage specification\nThe work is currently being focused on the correctness of the compiler and the proper code generation for all architectures and operating systems.\nThe language syntax is highly volatile at this point but you can take a look at the examples or the tests to get a perspective on the current status.\nDocumentation for all language features will follow once the core systems are stable.\nSource overview\nThis section is for contributors who want a high-level overview of the source code structure.\nPackages\n\narm - arm64 architecture\nasm - Generic assembler\nast - Abstract syntax tree\ncli - Command line interface\ncodegen - SSA to assembly code generation\ncompiler - Compiler frontend\nconfig - Build configuration\ncore - Defines Function and compiles tokens to SSA\ncpu - Types to represent a generic CPU\ndata - Data container that can re-use existing data\ndll - DLL support for Windows systems\nelf - ELF format for Linux executables\nerrors - Error handling that reports lines and columns\nexe - Generic executable format to calculate section offsets\nexpression - Expression parser generating trees\nfs - File system access\nglobal - Global variables like the working directory\nlinker - Frontend for generating executable files\nmacho - Mach-O format for Mac executables\nmemfile - Memory backed file descriptors\npe - PE format for Windows executables\nscanner - Scanner that parses top-level instructions\nset - Generic set implementation\nsizeof - Calculates the byte size of numbers\nssa - Static single assignment types\ntoken - Tokenizer\ntypes - Type system\nverbose - Verbose output\nx86 - x86-64 architecture\n\nTypical flow\n\nmain\ncli.Exec\ncompiler.Compile\nscanner.Scan\ncore.Compile\nlinker.Write\n\nFAQ\nHow tiny is a Hello World?\n\n\n\n\narm64\nx86-64\n\n\n\n\nüêß Linux\n646 bytes\n582 bytes\n\n\nüçè Mac\n49.3 KiB\n12.5 KiB\n\n\nü™ü Windows\n1.7 KiB\n1.7 KiB\n\n\n\nThis table often raises the question why Mac builds are so huge compared to the rest. The answer is in these few lines of their kernel code. None of the other operating systems force you to page-align sections on disk. In practice, however, it's not as bad as it sounds because the padding is a zero-filled area that barely consumes any disk space in sparse files.\nWhich platforms are supported?\n\n\n\n\narm64\nx86-64\n\n\n\n\nüêß Linux\n‚úîÔ∏è\n‚úîÔ∏è\n\n\nüçè Mac\n‚úîÔ∏è*\n‚úîÔ∏è\n\n\nü™ü Windows\n‚úîÔ∏è*\n‚úîÔ∏è\n\n\n\nThose marked with a star need testing. Please contact me if you have a machine with the marked architectures.\nHow is the assembly code quality?\nThe backend uses an SSA based IR which is also used by well established compilers like gcc, go and llvm. SSA makes it trivial to apply lots of common optimization passes to it. As such, the quality of the generated assembly is fairly high despite the young age of the project.\nWhich security features are supported?\nPIE\nAll executables are built as position independent executables supporting a dynamic base address.\nW^X\nAll memory pages are loaded with either execute or write permissions but never with both. Constant data is read-only.\n\n\n\n\nRead\nExecute\nWrite\n\n\n\n\nCode\n‚úîÔ∏è\n‚úîÔ∏è\n‚ùå\n\n\nData\n‚úîÔ∏è\n‚ùå\n‚ùå\n\n\n\nHow do I use it for scripting?\nThe compiler is actually so fast that it's possible to compile an entire script within microseconds.\n#!/usr/bin/env q\n\nimport io\n\nmain() {\n\tio.write(\"Hello\\n\")\n}\nCreate a file with the contents above and add permissions via chmod +x. Now you can execute it from anywhere. The generated machine code runs directly from RAM if the OS supports it.\nAny editor extensions?\nThere is one for VS Code but is only has syntax highlighting so far. You can clone the vscode-q repository into your extensions folder.\nNeovim support is planned.\nHow do I pronounce the name?\n/ÀàkjuÀê/ just like q in the English alphabet.\nFAQ: Contributors\nHow do I run the test suite?\nRun all tests:\ngo run gotest.tools/gotestsum@latest\nGenerate coverage:\ngo test -coverpkg=./... -coverprofile=cover.out ./...\nView coverage:\ngo tool cover -func cover.out\ngo tool cover -html cover.out\nHow do I run the benchmarks?\nRun compiler benchmarks:\ngo test ./tests -run='^$' -bench=. -benchmem\nRun compiler benchmarks in single-threaded mode:\nGOMAXPROCS=1 go test ./tests -run '^$' -bench . -benchmem\nGenerate profiling data:\ngo test ./tests -run='^$' -bench=. -benchmem -cpuprofile cpu.out -memprofile mem.out\nView profiling data:\ngo tool pprof --nodefraction=0.1 -http=:8080 ./cpu.out\ngo tool pprof --nodefraction=0.1 -http=:8080 ./mem.out\nIs there an IRC channel?\n#q on irc.urbach.dev.\nLicense\nPlease see the license documentation.\nCopyright\n¬© 2025 Eduard Urbach\n\n\t\t\t\n\t\t","length":5443,"excerpt":"üå± A minimal programming language and compiler.","siteName":"Git","publishedTime":null}