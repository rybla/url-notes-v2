{"title":"Squashing my dumb bugs and why I log build ids","byline":null,"dir":null,"lang":"en","content":"<div id=\"readability-page-1\" class=\"page\"><div>\n\n<p>\nI screwed something up the other day and figured it had enough meat on \nits bones to turn into a story.  So, okay, here we go.\n</p>\n<p>\nFor a while now, I've been doing some \"wrapping\" of return values in my \ncode.  It's C++ stuff, but it's something that's been inspired by what \nsome of my friends have been doing with Rust.  It's where instead of \njust returning a string from a function that might fail, I return \nsomething else that enforces some checks.\n</p>\n<p>\nBasically, I'm not allowed to call .value() or .error() on it until I've \nchecked to see if it succeeded or not.  If I do one of those things out \nof sequence, it will hit a CHECK and will nuke the program.  This \nnormally catches me fat-fingering something in development and never \nships out.\n</p>\n<p>\nSome of this code looks like this:\n</p>\n<pre>auto ua = req.util-&gt;UserAgent();\n\nif (ua()) {\n  req.set_user_agent(ua.value());\n}\n</pre>\n<p>\nIn that case, it's wrapping a string.  It's wrapped because it can fail!  \nSometimes there's no value available because someone decided they didn't \nwant to send that header in their request for some strange reason.  I \ndon't \"do\" \"sentinel values\", nulls, or other stuff like that, because I \nhave my little \"result string\" thing going on here.\n</p>\n<p>\nEasy enough, right?  Well, I found myself making some mistakes when \ndealing with a series of calls to things that could pass or fail which \nworked in a similar fashion.  They don't have a .value() but they can \nhave an .error() and they need to be checked.\n</p>\n<p>\nSometimes, in my editor, I'd do a \"delete 2-3 lines, then undelete \ntwice, then twiddle the second set\" thing for a spot where I had to \nmake two very similar calls in a row.  It might look like this:\n</p>\n<pre>auto ai = app_-&gt;Init();\n\nif (!ai()) {\n  log_something(\"blahblah failed: \" + ai.error());\n  // return something or other...\n}\n\nauto ni = net_-&gt;Init();\n\nif (!ni()) {\n  log_something(\"no shrubbery: \" + ai.error());\n  // return something blahblah...\n}\n</pre>\n<p>\nBut, do you see the bug?  I'm using ai.error in the second spot instead \nof ni.error.  ai is still available since it exists from that \"auto ai = \n...\" line to the bottom of the block, and there's no way to say \"hey, \ncompiler, throw a fit if anyone looks at this thing after this point\".\n</p>\n<p>\nI'd have to do something odd like sticking the whole mess into another { \n... } block just so ai would disappear, and while that would work, \nit also gets ugly.\n</p>\n<p>\nNot too long ago, I came up with something else based on some newer \nsyntax that can be wrangled up in C++.  It's apparently called \"if \nscope\", where you can define a variable in the course of doing a branch \non some condition, and then it only exists right there.\n</p>\n<p>\nIt looks like this:\n</p>\n<pre>if (auto ai = app_-&gt;Init(); !ai()) {\n  log_something(\"blahblah failed: \" + ai.error());\n  // return something or other...\n}\n</pre>\n<p>\nIt looks a little awkward at first, but it's pretty close to the \noriginal code, and it also has a nifty side-effect: \"ai\" doesn't live \nbeyond that one tiny little block where I report the error and then bail \nout.\n</p>\n<p>\nWith that in place, you can't make that \"ai instead of ni\" mistake from \nbefore.  That's a clear win and I've been converting my code to it in \nchunks all over the place.\n</p>\n<p>\nA couple of days ago, I did a change like that on some user-agent \nhandling code, but screwed up and did it like this:\n</p>\n<pre>if (auto ua = req.util-&gt;UserAgent(); !ua()) {\n  req.set_user_agent(ua.value());\n}\n</pre>\n<p>\nThat's basically saying: \"if they *didn't* send a user-agent, then add \nits value to the request we're building up\".  Now, had that code ever \nrun, it would have CHECKed and blown up right there, since calling \n.value() after it's returned false on the pass-fail check is not \nallowed.  But, nobody is doing that at the moment, so it never happened.\n</p>\n<p>\nThe other effect it had was that it never added the user-agent value to \nthe outgoing request when clients _did_ present one, and that's been the \ncase all of the time.\n</p>\n<p>\nSo, a few days ago, someone reported that their feed score reporting \npage said that they apparently didn't send that header with their \nrequests but they're sure that they did.  They started chasing a bug on \ntheir side.  I went \"hmmm, oh no...\", looked, and found it.\n</p>\n<p>\nIt's supposed to look like this:\n</p>\n<pre>if (auto ua = req.util-&gt;UserAgent(); ua()) {\n  req.set_user_agent(ua.value());\n}\n</pre>\n<p>\nSo, why did I put the ! in front?  Easy: most of the time, I'm handling \nerrors with this stuff and bailing out by returning early.  This is one \nof those relatively infrequent inverted situations where I want the \nvalue and jam it in there only if it exists.\n</p>\n<p>\nIt was a quick fix, but the damage was done.  A few hundred rows in the \ndatabase table picked up NULLs for that column while the bad version was \ndeployed on the web server.\n</p>\n<p>\nSo now let's talk about what I'm doing about it.  One thing I've been \ndoing all this time when logging hits to the \n<a href=\"https://rachelbythebay.com/w/2024/05/30/fs/\">feed score project</a>\nis that I also log the git commit hash from the source tree at the time \nit was built by my automatic processes.  It's just one more column in \nthe table, and it changes any time I push a new binary out there.\n</p>\n<p>\nWith that, it was possible to see that only this one build had the bug, \nand I didn't need to fix any other rows.  The other rows without UA data \nare that way because some goofball program is actually not sending the \nheader for whatever reason.\n</p>\n<p>\nNext, I changed the report page to add a colorful (and very \nstrange-looking) \"fingerprint\" of the build hash which had been logged \nall along but not exposed to users previously.  Every row in the results \ntable now sports an extra column which has a bunch of wacky Unicode \nbox-drawing characters around U+2580 all in different colors.  I use the \nbuild hash to set the colors and pick which of the 30 or so weird \ncharacters can go in each spot.\n</p>\n<p>\nIf this technique sounds familiar, you might be thinking of a post of \nmine from\n<a href=\"https://rachelbythebay.com/w/2011/08/11/stripes/\">August 2011</a>\nwhere it was using MD5 sums of argv strings to render color bars.\n</p>\n<p>\nThis time around, since other people are the intended audience, I can't \nrely on full-color vision, so that's why there's also a mash-up of \ncharacters.  Even if all you can see are shades of grey, you can still \nsee the groupings at a glance.\n</p>\n<p>\nSo now, whenever something seems strange, the fsr users can see if I \nchanged something and maybe save themselves from chasing a bug that's on \nmy end and not theirs.\n</p>\n<p>\nTo those people: sorry!  I still have to sit down and manually replace \nthe data in the table from the actual web server logs from that time \nperiod.  It'll fill in and then it'll look like nothing bad ever \nhappened.\n</p>\n<p>\nUntil then, well, just know that one particular version blob has my \n\"brown paper bag\" bug associated with it.\n</p>\n<p><img src=\"https://rachelbythebay.com/w/2025/08/03/scope/hb.png\" width=\"500\" height=\"555\" alt=\"HTML table showing etag and cache-control fields and the aforementioned &quot;hb&quot; for the CGI handler's build hash\"></p><p>\nBugs, bugs, bugs...\n</p>\n<p>\nAnd finally, yes, a test on this code would have caught this \npre-shipping.  Obviously.  You saw the part where I'm\n<a href=\"https://rachelbythebay.com/w/2024/12/17/packets/\">doing this for free,</a>\nright?\n</p>\n</div></div>","textContent":"\n\n\nI screwed something up the other day and figured it had enough meat on \nits bones to turn into a story.  So, okay, here we go.\n\n\nFor a while now, I've been doing some \"wrapping\" of return values in my \ncode.  It's C++ stuff, but it's something that's been inspired by what \nsome of my friends have been doing with Rust.  It's where instead of \njust returning a string from a function that might fail, I return \nsomething else that enforces some checks.\n\n\nBasically, I'm not allowed to call .value() or .error() on it until I've \nchecked to see if it succeeded or not.  If I do one of those things out \nof sequence, it will hit a CHECK and will nuke the program.  This \nnormally catches me fat-fingering something in development and never \nships out.\n\n\nSome of this code looks like this:\n\nauto ua = req.util->UserAgent();\n\nif (ua()) {\n  req.set_user_agent(ua.value());\n}\n\n\nIn that case, it's wrapping a string.  It's wrapped because it can fail!  \nSometimes there's no value available because someone decided they didn't \nwant to send that header in their request for some strange reason.  I \ndon't \"do\" \"sentinel values\", nulls, or other stuff like that, because I \nhave my little \"result string\" thing going on here.\n\n\nEasy enough, right?  Well, I found myself making some mistakes when \ndealing with a series of calls to things that could pass or fail which \nworked in a similar fashion.  They don't have a .value() but they can \nhave an .error() and they need to be checked.\n\n\nSometimes, in my editor, I'd do a \"delete 2-3 lines, then undelete \ntwice, then twiddle the second set\" thing for a spot where I had to \nmake two very similar calls in a row.  It might look like this:\n\nauto ai = app_->Init();\n\nif (!ai()) {\n  log_something(\"blahblah failed: \" + ai.error());\n  // return something or other...\n}\n\nauto ni = net_->Init();\n\nif (!ni()) {\n  log_something(\"no shrubbery: \" + ai.error());\n  // return something blahblah...\n}\n\n\nBut, do you see the bug?  I'm using ai.error in the second spot instead \nof ni.error.  ai is still available since it exists from that \"auto ai = \n...\" line to the bottom of the block, and there's no way to say \"hey, \ncompiler, throw a fit if anyone looks at this thing after this point\".\n\n\nI'd have to do something odd like sticking the whole mess into another { \n... } block just so ai would disappear, and while that would work, \nit also gets ugly.\n\n\nNot too long ago, I came up with something else based on some newer \nsyntax that can be wrangled up in C++.  It's apparently called \"if \nscope\", where you can define a variable in the course of doing a branch \non some condition, and then it only exists right there.\n\n\nIt looks like this:\n\nif (auto ai = app_->Init(); !ai()) {\n  log_something(\"blahblah failed: \" + ai.error());\n  // return something or other...\n}\n\n\nIt looks a little awkward at first, but it's pretty close to the \noriginal code, and it also has a nifty side-effect: \"ai\" doesn't live \nbeyond that one tiny little block where I report the error and then bail \nout.\n\n\nWith that in place, you can't make that \"ai instead of ni\" mistake from \nbefore.  That's a clear win and I've been converting my code to it in \nchunks all over the place.\n\n\nA couple of days ago, I did a change like that on some user-agent \nhandling code, but screwed up and did it like this:\n\nif (auto ua = req.util->UserAgent(); !ua()) {\n  req.set_user_agent(ua.value());\n}\n\n\nThat's basically saying: \"if they *didn't* send a user-agent, then add \nits value to the request we're building up\".  Now, had that code ever \nrun, it would have CHECKed and blown up right there, since calling \n.value() after it's returned false on the pass-fail check is not \nallowed.  But, nobody is doing that at the moment, so it never happened.\n\n\nThe other effect it had was that it never added the user-agent value to \nthe outgoing request when clients _did_ present one, and that's been the \ncase all of the time.\n\n\nSo, a few days ago, someone reported that their feed score reporting \npage said that they apparently didn't send that header with their \nrequests but they're sure that they did.  They started chasing a bug on \ntheir side.  I went \"hmmm, oh no...\", looked, and found it.\n\n\nIt's supposed to look like this:\n\nif (auto ua = req.util->UserAgent(); ua()) {\n  req.set_user_agent(ua.value());\n}\n\n\nSo, why did I put the ! in front?  Easy: most of the time, I'm handling \nerrors with this stuff and bailing out by returning early.  This is one \nof those relatively infrequent inverted situations where I want the \nvalue and jam it in there only if it exists.\n\n\nIt was a quick fix, but the damage was done.  A few hundred rows in the \ndatabase table picked up NULLs for that column while the bad version was \ndeployed on the web server.\n\n\nSo now let's talk about what I'm doing about it.  One thing I've been \ndoing all this time when logging hits to the \nfeed score project\nis that I also log the git commit hash from the source tree at the time \nit was built by my automatic processes.  It's just one more column in \nthe table, and it changes any time I push a new binary out there.\n\n\nWith that, it was possible to see that only this one build had the bug, \nand I didn't need to fix any other rows.  The other rows without UA data \nare that way because some goofball program is actually not sending the \nheader for whatever reason.\n\n\nNext, I changed the report page to add a colorful (and very \nstrange-looking) \"fingerprint\" of the build hash which had been logged \nall along but not exposed to users previously.  Every row in the results \ntable now sports an extra column which has a bunch of wacky Unicode \nbox-drawing characters around U+2580 all in different colors.  I use the \nbuild hash to set the colors and pick which of the 30 or so weird \ncharacters can go in each spot.\n\n\nIf this technique sounds familiar, you might be thinking of a post of \nmine from\nAugust 2011\nwhere it was using MD5 sums of argv strings to render color bars.\n\n\nThis time around, since other people are the intended audience, I can't \nrely on full-color vision, so that's why there's also a mash-up of \ncharacters.  Even if all you can see are shades of grey, you can still \nsee the groupings at a glance.\n\n\nSo now, whenever something seems strange, the fsr users can see if I \nchanged something and maybe save themselves from chasing a bug that's on \nmy end and not theirs.\n\n\nTo those people: sorry!  I still have to sit down and manually replace \nthe data in the table from the actual web server logs from that time \nperiod.  It'll fill in and then it'll look like nothing bad ever \nhappened.\n\n\nUntil then, well, just know that one particular version blob has my \n\"brown paper bag\" bug associated with it.\n\n\nBugs, bugs, bugs...\n\n\nAnd finally, yes, a test on this code would have caught this \npre-shipping.  Obviously.  You saw the part where I'm\ndoing this for free,\nright?\n\n","length":6874,"excerpt":"I screwed something up the other day and figured it had enough meat on \nits bones to turn into a story.  So, okay, here we go.","siteName":null,"publishedTime":null}