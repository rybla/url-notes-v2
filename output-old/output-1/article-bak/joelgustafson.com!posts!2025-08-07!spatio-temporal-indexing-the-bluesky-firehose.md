{"title":"Spatio-temporal indexing the BlueSky firehose","byline":null,"dir":null,"lang":null,"content":"<div id=\"readability-page-1\" class=\"page\"><div id=\"__next\"><main><div>\n<p><a href=\"https://joelgustafson.com/\">Joel Gustafson</a> / <a href=\"https://joelgustafson.com/posts\">Posts</a> / <em>2025-08-07</em></p>\n<hr>\n<p>I recently added a \"spatial feed\" to <a href=\"https://aurora.ndimensional.xyz/\">Aurora</a>, my map of Bluesky. Now, in addition to seeing community clusters laid out on a giant map, you can also see a real-time of posts from just the accounts currently in view. This works smoothly at all scales — you can see the most recent posts from the entire network when zoomed all the way out, and local posts from any neighborhood when zoomed in.</p>\n<p>How does this work?</p>\n<p>This is actually the first (and only) backend service that I've had to deploy for this project. To compute the clustering and layout for the map, I index the follow graph in a SQLite database that only lives on my home server, do all the data processing locally, and just push static assets to a Cloudflare R2 bucket at the end that the web client fetches directly.</p>\n<blockquote>\n<p>check out my <a href=\"https://joelgustafson.com/posts/2024-11-12/visualizing-13-million-bluesky-users\">previous post</a> about building Aurora using WebGPU and UMAP!</p>\n</blockquote>\n<p>But adding spatial feeds means having the web client make constant queries for post URIs in arbitrary map areas, which it can then \"hydrate\" into post content from the Bluesky API directly. I didn't want to expose public ports from my home server, so that means deploying a firehose consumer to the cloud.</p>\n<hr>\n<p>What does this firehose consumer need to do? It receives a stream of posts via WebSocket from a <a href=\"https://github.com/bluesky-social/jetstream/tree/main\">Jetstream</a> endpoint, and needs to index them in some way that supports <strong>arbitrary spatial queries</strong>.</p>\n<p>We can give the indexer access to a local SQLite database with the current map coordinates of each user, which only changes when I release montly snapshots of the map. This means we just need to implement a simple <code>observe</code>/<code>query</code> interface.</p>\n<pre><code><span>type</span> <span>Post</span> <span>=</span> <span>{</span>\n  <span>id</span><span>:</span> <span>number</span> <span>// auto-incrementing rowid from SQLite</span>\n  <span>x</span><span>:</span> <span>number</span>\n  <span>y</span><span>:</span> <span>number</span>\n<span>}</span>\n\n<span>type</span> <span>Area</span> <span>=</span> <span>{</span>\n  <span>minX</span><span>:</span> <span>number</span>\n  <span>maxX</span><span>:</span> <span>number</span>\n  <span>minY</span><span>:</span> <span>number</span>\n  <span>maxY</span><span>:</span> <span>number</span>\n<span>}</span>\n\n<span>// in-memory cache for spatial queries</span>\n<span>class</span> <span>Indexer</span> <span>{</span>\n  <span>public</span> <span>constructor</span><span>(</span><span>bounds</span><span>:</span> <span>Area</span><span>)</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>public</span> <span>observe</span><span>(</span><span>post</span><span>:</span> <span>Post</span><span>)</span><span>:</span> <span>void</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n\n  <span>public</span> <span>query</span><span>(</span><span>area</span><span>:</span> <span>Area</span><span>,</span> <span>limit</span><span>:</span> <span>number</span><span>)</span><span>:</span> <span>Post</span><span>[</span><span>]</span> <span>{</span>\n    <span>// ...</span>\n  <span>}</span>\n<span>}</span></code></pre>\n<p>Furthermore, we would like the resulting <code>Post[]</code> array to be the most recent posts from that area. It's not that much fun if the feed only some loosely-sorted sampling of recent posts — we want to see things right away as they are posted.</p>\n<hr>\n<p>So! We want to query within arbitrary rectangualar areas while simultaneously sorting by time. Clients will hit this query endpoint fairly often. The map has tens of millions of accounts and I expect to index at least tens of millions of posts. I want the feed to refresh quickly, and some quick tests confirmed that the \"dumb\" approaches were not going to cut it.</p>\n<p>It turns out that trying to both filter by 2d space <em>and</em> sort by time is really difficult. For example, I had thought at first that I could just use a 3-dimensional <a href=\"https://www.sqlite.org/rtree.html\">SQLite R-tree</a>, using time as the third axis. That would let us query for posts within arbitrary 3d bounding boxes, but R-trees don't actually let you <em>sort</em> by any of the axes. This doesn't help at all for large query areas covering a huge number of users.</p>\n<p>So then what? You could try to make several queries with a 3d R-tree, slicing the time axis by successive intervals until enough posts are found, possibly using the size of the query area to derive an expected density of posts in each time interval. But this seemed unsatisfying, and I didn't want to make something that relied on a \"uniform density\" assumption that may or may not hold. Surely there's another data structure that can do this more directly?</p>\n<p>The <a href=\"https://en.wikipedia.org/wiki/Priority_search_tree\">Priority search tree</a> solves this problem for 1-dimensional key ranges while sorting by a \"priority\" value. We essentially need to filter by 2-dimensional spatial ranges, plus sorting by a priority value, but priority search trees cannot be naively generalized to higher dimensions. The <a href=\"https://en.wikipedia.org/wiki/Priority_R-tree\">Priority R-tree</a> has a promising name but turns out to be unrelated. <a href=\"https://github.com/timescale/timescaledb\">TimescaleDB</a> supports sophisticated spatio-temporal query patterns, using some complicated table partitioning scheme (??), but I didn't want to pay for a hosted Postgres database in addition to the firehose consumer. I really just want an in-memory index.</p>\n<hr>\n<p>A general solution would have been great, but Timescale's architecture seemed to suggest that a straighforward generalization of \"sortable R-trees\" or \"2d Priority search trees\" simply does not exist. In a situation like that, your only move is to look for aspects of your specific use case that let you avoid solving the big problem in full generality.</p>\n<p>In my case, I don't really need to iterate over <em>all</em> posts in an arbitrary area in chronological order. In fact, I'm going to be garbage-collecting old posts anyway, keeping only the most recent <code>k</code> in every bucket (for some partitioning of the area into buckets). So it's fine if each query is limited to a fixed top-<code>k</code> limit, even global queries over the entire map.</p>\n<p>This lets me use a relatively simple custom data structure: a \"quadtree of ring buffers\".</p>\n<p>The first step is building a quadtree over the positions of all the users. Unlike a normal quadtree, where each item always gets its own leaf node, we'll only split nodes once they exceed our capacity <code>k</code>. This gives us a tree whose leaves are our <code>k</code>-buckets that partition the global area, which we will use for garbage collection later.</p>\n<p>Just for fun, I decided to write the quadtree-of-ring-buffers as an in-memory data structure in Zig, and expose it to NodeJS as a <a href=\"https://nodejs.org/api/n-api.html\">native NAPI module</a>.</p>\n<pre><code><span>pub</span> <span>const</span> <span>Quadrant</span> = <span>enum</span><span>(</span><span>u2</span><span>)</span> <span>{</span> sw = <span>0,</span> nw = <span>1,</span> se = <span>2,</span> ne = <span>3 </span><span>}</span><span>;</span>\n\n<span>pub</span> <span>const</span> <span>NodeId</span> = <span>u32</span><span>;</span> <span>// zero for empty slot</span>\n\n<span>pub</span> <span>const</span> <span>Node</span> = <span>struct</span> <span>{</span>\n\tne<span>:</span> <span>NodeId</span><span>,</span>\n\tnw<span>:</span> <span>NodeId</span><span>,</span>\n\tsw<span>:</span> <span>NodeId</span><span>,</span>\n\tse<span>:</span> <span>NodeId</span><span>,</span>\n\n\tcapacity<span>:</span> <span>usize</span><span>,</span>\n\n\t<span>pub</span> <span>inline</span> <span>fn</span> <span>getQuadrant</span><span>(</span>self<span>:</span> <span>Node</span><span>,</span> q<span>:</span> <span>Quadrant</span><span>)</span> <span>NodeID</span> <span>{</span>\n\t\t<span>// ...</span>\n\t<span>}</span>\n\n\t<span>pub</span> <span>inline</span> <span>fn</span> <span>isEmpty</span><span>(</span>self<span>:</span> <span>Node</span><span>)</span> <span>bool</span> <span>{</span>\n\t\treturn self<span>.</span>ne == <span>0 </span><span>and</span> self<span>.</span>nw == <span>0 </span><span>and</span> self<span>.</span>sw == <span>0 </span><span>and</span> self<span>.</span>se == <span>0;</span>\n\t<span>}</span>\n\n\t<span>// ...</span>\n<span>}</span><span>;</span>\n\n<span>// represents a square map tile</span>\n<span>pub</span> <span>const</span> <span>Tile</span> = <span>struct</span> <span>{</span>\n\tcenter<span>:</span> <span>@Vector</span><span>(</span><span>2,</span> <span>f32</span><span>)</span><span>,</span>\n\tsize<span>:</span> <span>f32</span><span>,</span> <span>// side length of tile</span>\n\n\t<span>/// return a child quadrant</span>\n\t<span>pub</span> <span>fn</span> divide<span>(</span>self<span>:</span> Tile<span>,</span> q<span>:</span> Quadrant<span>)</span> Tile <span>{</span>\n\t\t<span>// ...</span>\n\t<span>}</span>\n\n\t<span>/// locate a point within a child quadrant</span>\n\t<span>pub</span> <span>fn</span> <span>locate</span><span>(</span>self<span>:</span> <span>Tile</span><span>,</span> point<span>:</span> <span>@Vector</span><span>(</span><span>2,</span> <span>f32</span><span>)</span><span>)</span> <span>Quadrant</span> <span>{</span>\n\t\t<span>// ...</span>\n\t<span>}</span>\n<span>}</span><span>;</span>\n\n<span>// our quadtree-of-ring-buffers spatio-temporal cache</span>\n<span>const</span> <span>QtCache</span> = <span>struct</span> <span>{</span>\n\troot<span>:</span> <span>Tile</span><span>,</span> <span>// bounding square for the global map</span>\n\n\t<span>// NodeId values are an index into nodes.items.</span>\n\t<span>// the first element of nodes.items is the root node.</span>\n\tnodes<span>:</span> <span>std</span><span>.</span>ArrayList<span>(</span>Node<span>)</span><span>,</span>\n\n\t<span>// ...</span>\n<span>}</span><span>;</span></code></pre>\n<p>In addition to this capacity number, each quadtree node also has its own buffer for the most recent <code>k</code> posts within its tile area. Since we need to index a constant stream of new posts, we can use a ring buffer to avoid shifting existing contents around.</p>\n<pre><code><span>const</span> <span>std</span> = <span>@import</span><span>(</span><span>\"std\"</span><span>)</span><span>;</span>\n\n<span>pub</span> <span>fn</span> <span>RingBuffer</span><span>(</span><span>comptime</span> T<span>:</span> <span>type</span><span>,</span> <span>comptime</span> K<span>:</span> <span>usize</span><span>)</span> <span>type</span> <span>{</span>\n    return <span>struct</span> <span>{</span>\n        <span>const</span> <span>Self</span> = <span>@This</span><span>(</span><span>)</span><span>;</span>\n\n        <span>pub</span> <span>const</span> <span>Ring</span> = <span>struct</span> <span>{</span>\n            head<span>:</span> []<span>const</span> <span>T</span><span>,</span>\n            tail<span>:</span> []<span>const</span> <span>T</span><span>,</span>\n        <span>}</span><span>;</span>\n\n        items<span>:</span> [K]T = <span>undefined</span><span>,</span>\n        start<span>:</span> <span>usize</span> = <span>0,</span>\n        len<span>:</span> <span>usize</span> = <span>0,</span>\n\n        <span>pub</span> <span>fn</span> reset<span>(</span>self<span>:</span> *Self<span>)</span> <span>void</span> <span>{</span>\n            self<span>.</span>start = <span>0;</span>\n            self<span>.</span>len = <span>0;</span>\n        <span>}</span>\n\n        <span>pub</span> <span>fn</span> <span>push</span><span>(</span>self<span>:</span> *<span>Self</span><span>,</span> item<span>:</span> <span>T</span><span>)</span> <span>void</span> <span>{</span>\n            <span>// ... blah blah blah</span>\n        <span>}</span>\n\n        <span>pub</span> <span>fn</span> <span>getRing</span><span>(</span>self<span>:</span> *<span>const</span> <span>Self</span><span>)</span> <span>Ring</span> <span>{</span>\n            <span>// ... blah blah blah</span>\n        <span>}</span>\n    <span>}</span><span>;</span>\n<span>}</span></code></pre>\n<p>Then we add a ring buffer for posts to each of our quadtree nodes. For each post, we'll store both the post id (a SQLite rowid) and also the x/y coordinates of the user. The rest of the post and user data are persisted in a SQLite database; posts get garbage-collected in the background once they rotate out of the leaf bucket's ring buffer.</p>\n<pre><code><span>pub</span> <span>const</span> <span>PostId</span> = <span>u32</span><span>;</span>\n<span>pub</span> <span>const</span> <span>Post</span> = <span>struct</span> <span>{</span>\n    id<span>:</span> <span>PostId</span><span>,</span>\n    position<span>:</span> <span>@Vector</span><span>(</span><span>2,</span> <span>f32</span><span>)</span>\n\n    <span>// these ids are monotonic rowids from SQLite so they trivially sort by time</span>\n    <span>pub</span> <span>fn</span> lessThan<span>(</span>_<span>:</span> <span>void</span><span>,</span> lhs<span>:</span> <span>Post</span><span>,</span> rhs<span>:</span> <span>Post</span><span>)</span> <span>bool</span> <span>{</span>\n        return lhs<span>.</span>id &lt; rhs<span>.</span>id<span>;</span>\n    <span>}</span>\n<span>}</span><span>;</span>\n\n<span>const</span> <span>K</span> = <span>24;</span>\n\n<span>pub</span> <span>const</span> Node = <span>struct</span> <span>{</span>\n\t<span>// ...</span>\n\n\tbuffer<span>:</span> <span>RingBuffer</span><span>(</span>Post<span>,</span> K<span>)</span><span>,</span>\n<span>}</span><span>;</span></code></pre>\n<p>This means that inserting a post into the quadtree just involves descending the tree to the appropriate leaf bucket, pushing the post onto each node's buffer along the way.</p>\n<pre><code><span>pub</span> <span>const</span> <span>QtCache</span> = <span>struct</span> <span>{</span>\n\t<span>// ...</span>\n\n\t<span>pub</span> <span>inline</span> <span>fn</span> <span>observe</span><span>(</span>self<span>:</span> *<span>QtCache</span><span>,</span> post<span>:</span> <span>Post</span><span>)</span> <span>void</span> <span>{</span>\n\t\t<span>if</span> <span>(</span>self<span>.</span>tree<span>.</span>items<span>.</span>len &gt; <span>0)</span> <span>{</span>\n\t\t\tself<span>.</span>observeNode<span>(</span><span>0,</span> self<span>.</span>root<span>,</span> post<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t<span>}</span>\n\n\t<span>fn</span> <span>observeNode</span><span>(</span>self<span>:</span> *<span>QtCache</span><span>,</span> id<span>:</span> <span>NodeId</span><span>,</span> tile<span>:</span> <span>Tile</span><span>,</span> post<span>:</span> <span>Post</span><span>)</span> <span>void</span> <span>{</span>\n\t\tself<span>.</span>tree<span>.</span>items[idx]<span>.</span>buffer<span>.</span>push<span>(</span>post<span>)</span><span>;</span>\n\n\t\t<span>const</span> <span>quadrant</span> = tile<span>.</span>locate<span>(</span>post<span>.</span>position<span>)</span><span>;</span>\n\t\t<span>const</span> <span>child</span> = self<span>.</span>tree<span>.</span>items[id]<span>.</span>getQuadrant<span>(</span>quadrant<span>)</span><span>;</span>\n\t\t<span>if</span> <span>(</span>child != <span>0)</span> <span>{</span>\n\t\t\tself<span>.</span>observeNode<span>(</span>child<span>,</span> tile<span>.</span>divide<span>(</span>quadrant<span>)</span><span>,</span> item<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t<span>}</span>\n<span>}</span><span>;</span></code></pre>\n<p>Querying is only a little more complicated. The trivial case is querying an area exactly equal to a quadtree node tile, but in general queries can be any rectangular area. This means we have to traverse all quadtree nodes that intersect the query area, and collect the top-<code>k</code> results in a min-heap as we go. (We don't need to recurse into a node's children if it is entirely contained within the query area.)</p>\n<p>First we make a little generic <code>MinHeap</code>...</p>\n<pre><code><span>pub</span> <span>fn</span> <span>MinHeap</span><span>(</span><span>comptime</span> T<span>:</span> <span>type</span><span>,</span> <span>comptime</span> K<span>:</span> <span>usize</span><span>)</span> <span>type</span> <span>{</span>\n    return <span>struct</span> <span>{</span>\n        <span>const</span> <span>Self</span> = <span>@This</span><span>(</span><span>)</span><span>;</span>\n\n        heap<span>:</span> [K]T = <span>undefined</span><span>,</span>\n        size<span>:</span> <span>usize</span> = <span>0,</span>\n\n        <span>pub</span> <span>fn</span> init<span>(</span><span>)</span> Self <span>{</span>\n            <span>// ...</span>\n        <span>}</span>\n\n        <span>pub</span> <span>fn</span> <span>clear</span><span>(</span>self<span>:</span> *<span>Self</span><span>)</span> <span>void</span> <span>{</span>\n            <span>// ...</span>\n        <span>}</span>\n\n\t    <span>pub</span> <span>fn</span> <span>add</span><span>(</span>self<span>:</span> *<span>Self</span><span>,</span> value<span>:</span> <span>T</span><span>)</span> <span>void</span> <span>{</span>\n\t\t    <span>// ...</span>\n\t    <span>}</span>\n\n\t\t<span>pub</span> <span>inline</span> <span>fn</span> <span>getItems</span><span>(</span>self<span>:</span> <span>Self</span><span>)</span> []<span>const</span> <span>T</span> <span>{</span>\n\t\t\treturn self<span>.</span>heap[0..self<span>.</span>size]<span>;</span>\n\t\t<span>}</span>\n    <span>}</span><span>;</span>\n<span>}</span></code></pre>\n<p>... then we add it to our <code>QtCache</code> and write the recursive <code>queryNode</code>.</p>\n<pre><code><span>const</span> <span>K</span> = <span>24;</span>\n\n<span>pub</span> <span>const</span> QtCache = <span>struct</span> <span>{</span>\n\troot<span>:</span> <span>Tile</span><span>,</span> <span>// bounding square for the global map</span>\n\n\t<span>// NodeId values are an index into nodes.items.</span>\n\t<span>// the first element of nodes.items is the root node.</span>\n\tnodes<span>:</span> <span>std</span><span>.</span>ArrayList<span>(</span>Node<span>)</span><span>,</span>\n\n\theap<span>:</span> MinHeap<span>(</span>PostId<span>,</span> K<span>)</span>\n\n\t<span>// ...</span>\n\n\t<span>pub</span> <span>const</span> Query = <span>struct</span> <span>{</span>\n\t\tmin<span>:</span> <span>@Vector</span><span>(</span><span>2,</span> <span>f32</span><span>)</span><span>,</span>\n\t\tmax<span>:</span> <span>@Vector</span><span>(</span><span>2,</span> <span>f32</span><span>)</span><span>,</span>\n\n\t\t<span>/// do the query rectangle and the area tile intersect?</span>\n\t\t<span>pub</span> <span>inline</span> <span>fn</span> intersect<span>(</span>self<span>:</span> <span>Query</span><span>,</span> tile<span>:</span> <span>Tile</span><span>)</span> <span>bool</span> <span>{</span>\n\t\t\t<span>// ...</span>\n\t\t<span>}</span>\n\n\t\t<span>/// does the query rectangle include the point?</span>\n\t\t<span>pub</span> <span>inline</span> <span>fn</span> <span>includes</span><span>(</span>self<span>:</span> <span>Query</span><span>,</span> p<span>:</span> <span>@Vector</span><span>(</span><span>2,</span> <span>f32</span><span>)</span><span>)</span> <span>bool</span> <span>{</span>\n\t\t\t<span>// ...</span>\n\t\t<span>}</span>\n\t<span>}</span><span>;</span>\n\n\t<span>pub</span> <span>fn</span> <span>query</span><span>(</span>self<span>:</span> *<span>QtCache</span><span>,</span> q<span>:</span> <span>Query</span><span>)</span> []<span>const</span> <span>PostId</span> <span>{</span>\n\t\t<span>// use size of the query rectangle to derive a</span>\n\t\t<span>// lower bound of quadtree node size.</span>\n\t\t<span>// we won't traverse into children below this size.</span>\n\t\t<span>const</span> <span>divisor</span><span>:</span> <span>f32</span> = <span>2;</span>\n\t\t<span>const</span> unit = <span>@ceil</span><span>(</span><span>@log2</span><span>(</span><span>@reduce</span><span>(</span><span>.</span>Max<span>,</span> q<span>.</span>max - q<span>.</span>min<span>)</span> / divisor<span>)</span><span>)</span><span>;</span>\n\t\t<span>const</span> <span>threshold</span> = std<span>.</span>math<span>.</span>pow<span>(</span><span>f32</span><span>,</span> <span>2,</span> unit<span>)</span><span>;</span>\n\n\t\tself<span>.</span>heap<span>.</span>clear<span>(</span><span>)</span><span>;</span>\n\t\tself<span>.</span>queryNode<span>(</span><span>0,</span> self<span>.</span>root<span>,</span> q<span>,</span> s<span>)</span><span>;</span>\n\n\t\t<span>// the top-k posts here aren't actually sorted within</span>\n\t\t<span>// themselves since they're in heap order, but we can</span>\n\t\t<span>// just sort them on the NodeJS side before resolving</span>\n\t\t<span>// the ids to URIs.</span>\n\t\treturn self<span>.</span>heap<span>.</span>getItems<span>(</span><span>)</span><span>;</span>\n\t<span>}</span>\n\n\t<span>fn</span> <span>queryNode</span><span>(</span>self<span>:</span> *<span>QtCache</span><span>,</span> id<span>:</span> <span>NodeId</span><span>,</span> tile<span>:</span> <span>Tile</span><span>,</span> q<span>:</span> <span>Query</span><span>,</span> threshold<span>:</span> <span>f32</span><span>)</span> <span>void</span> <span>{</span>\n\t\t<span>if</span> <span>(</span>!q<span>.</span>intersect<span>(</span>tile<span>)</span><span>)</span> <span>{</span>\n\t\t\treturn<span>;</span>\n\t\t<span>}</span>\n\n\t\t<span>const</span> <span>node</span> = self<span>.</span>tree<span>.</span>items[id]<span>;</span>\n\t\t<span>if</span> <span>(</span>node<span>.</span>isEmpty<span>(</span><span>)</span> <span>or</span> tile<span>.</span>s &lt;= threshold<span>)</span> <span>{</span>\n\t\t\t<span>const</span> <span>ring</span> = node<span>.</span>buffer<span>.</span>getRing<span>(</span><span>)</span><span>;</span>\n\t\t\t<span>for</span> <span>(</span>ring<span>.</span>head<span>)</span> |post|\n\t\t\t\t<span>if</span> <span>(</span>q<span>.</span>includes<span>(</span>post<span>.</span>position<span>)</span><span>)</span> self<span>.</span>heap<span>.</span>add<span>(</span>post<span>.</span>id<span>)</span><span>;</span>\n\t\t\t<span>for</span> <span>(</span>ring<span>.</span>tail<span>)</span> |post|\n\t\t\t\t<span>if</span> <span>(</span>q<span>.</span>includes<span>(</span>post<span>.</span>position<span>)</span><span>)</span> self<span>.</span>heap<span>.</span>add<span>(</span>post<span>.</span>id<span>)</span><span>;</span>\n\t\t<span>}</span> <span>else</span> <span>{</span>\n\t\t\t<span>if</span> <span>(</span>node<span>.</span>ne != <span>0)</span> self<span>.</span>queryNode<span>(</span>node<span>.</span>ne<span>,</span> tile<span>.</span>divide<span>(</span><span>.</span>ne<span>)</span><span>,</span> q<span>,</span> threshold<span>)</span><span>;</span>\n\t\t\t<span>if</span> <span>(</span>node<span>.</span>nw != <span>0)</span> self<span>.</span>queryNode<span>(</span>node<span>.</span>nw<span>,</span> tile<span>.</span>divide<span>(</span><span>.</span>nw<span>)</span><span>,</span> q<span>,</span> threshold<span>)</span><span>;</span>\n\t\t\t<span>if</span> <span>(</span>node<span>.</span>sw != <span>0)</span> self<span>.</span>queryNode<span>(</span>node<span>.</span>sw<span>,</span> tile<span>.</span>divide<span>(</span><span>.</span>sw<span>)</span><span>,</span> q<span>,</span> threshold<span>)</span><span>;</span>\n\t\t\t<span>if</span> <span>(</span>node<span>.</span>se != <span>0)</span> self<span>.</span>queryNode<span>(</span>node<span>.</span>se<span>,</span> tile<span>.</span>divide<span>(</span><span>.</span>se<span>)</span><span>,</span> q<span>,</span> threshold<span>)</span><span>;</span>\n\t\t<span>}</span>\n\t<span>}</span>\n<span>}</span><span>;</span></code></pre>\n<p>Nice! An in-memory spatio-temporal index! And we actually wrote both <code>observe</code> and <code>query</code> as zero-allocation methods!</p>\n<p>I won't go over compiling the quadtree to a native NodeJS module, but you can look at the Zig build configuration in the source repo if you're interested.</p>\n<p>I deployed all this to fly.io for ~$10/month, including a persistent volume for the SQLite databases. Bluesky currently generates ~100 posts per second, and the index caches around 10 million total recent posts with less than 1GB total memory usage. Spatial queries from the Aurora web client take just around 1-3ms inside <code>QtCache</code>, dominated by ~12-20ms of network overhead to and from the client.</p>\n<p>If your browser supports WebGPU, you can check out the map yourself at <a href=\"https://aurora.ndimensional.xyz/\">https://aurora.ndimensional.xyz</a> and pop open the left sidebar to see the spatial feed.</p></div></main></div></div>","textContent":"\nJoel Gustafson / Posts / 2025-08-07\n\nI recently added a \"spatial feed\" to Aurora, my map of Bluesky. Now, in addition to seeing community clusters laid out on a giant map, you can also see a real-time of posts from just the accounts currently in view. This works smoothly at all scales — you can see the most recent posts from the entire network when zoomed all the way out, and local posts from any neighborhood when zoomed in.\nHow does this work?\nThis is actually the first (and only) backend service that I've had to deploy for this project. To compute the clustering and layout for the map, I index the follow graph in a SQLite database that only lives on my home server, do all the data processing locally, and just push static assets to a Cloudflare R2 bucket at the end that the web client fetches directly.\n\ncheck out my previous post about building Aurora using WebGPU and UMAP!\n\nBut adding spatial feeds means having the web client make constant queries for post URIs in arbitrary map areas, which it can then \"hydrate\" into post content from the Bluesky API directly. I didn't want to expose public ports from my home server, so that means deploying a firehose consumer to the cloud.\n\nWhat does this firehose consumer need to do? It receives a stream of posts via WebSocket from a Jetstream endpoint, and needs to index them in some way that supports arbitrary spatial queries.\nWe can give the indexer access to a local SQLite database with the current map coordinates of each user, which only changes when I release montly snapshots of the map. This means we just need to implement a simple observe/query interface.\ntype Post = {\n  id: number // auto-incrementing rowid from SQLite\n  x: number\n  y: number\n}\n\ntype Area = {\n  minX: number\n  maxX: number\n  minY: number\n  maxY: number\n}\n\n// in-memory cache for spatial queries\nclass Indexer {\n  public constructor(bounds: Area) {\n    // ...\n  }\n\n  public observe(post: Post): void {\n    // ...\n  }\n\n  public query(area: Area, limit: number): Post[] {\n    // ...\n  }\n}\nFurthermore, we would like the resulting Post[] array to be the most recent posts from that area. It's not that much fun if the feed only some loosely-sorted sampling of recent posts — we want to see things right away as they are posted.\n\nSo! We want to query within arbitrary rectangualar areas while simultaneously sorting by time. Clients will hit this query endpoint fairly often. The map has tens of millions of accounts and I expect to index at least tens of millions of posts. I want the feed to refresh quickly, and some quick tests confirmed that the \"dumb\" approaches were not going to cut it.\nIt turns out that trying to both filter by 2d space and sort by time is really difficult. For example, I had thought at first that I could just use a 3-dimensional SQLite R-tree, using time as the third axis. That would let us query for posts within arbitrary 3d bounding boxes, but R-trees don't actually let you sort by any of the axes. This doesn't help at all for large query areas covering a huge number of users.\nSo then what? You could try to make several queries with a 3d R-tree, slicing the time axis by successive intervals until enough posts are found, possibly using the size of the query area to derive an expected density of posts in each time interval. But this seemed unsatisfying, and I didn't want to make something that relied on a \"uniform density\" assumption that may or may not hold. Surely there's another data structure that can do this more directly?\nThe Priority search tree solves this problem for 1-dimensional key ranges while sorting by a \"priority\" value. We essentially need to filter by 2-dimensional spatial ranges, plus sorting by a priority value, but priority search trees cannot be naively generalized to higher dimensions. The Priority R-tree has a promising name but turns out to be unrelated. TimescaleDB supports sophisticated spatio-temporal query patterns, using some complicated table partitioning scheme (??), but I didn't want to pay for a hosted Postgres database in addition to the firehose consumer. I really just want an in-memory index.\n\nA general solution would have been great, but Timescale's architecture seemed to suggest that a straighforward generalization of \"sortable R-trees\" or \"2d Priority search trees\" simply does not exist. In a situation like that, your only move is to look for aspects of your specific use case that let you avoid solving the big problem in full generality.\nIn my case, I don't really need to iterate over all posts in an arbitrary area in chronological order. In fact, I'm going to be garbage-collecting old posts anyway, keeping only the most recent k in every bucket (for some partitioning of the area into buckets). So it's fine if each query is limited to a fixed top-k limit, even global queries over the entire map.\nThis lets me use a relatively simple custom data structure: a \"quadtree of ring buffers\".\nThe first step is building a quadtree over the positions of all the users. Unlike a normal quadtree, where each item always gets its own leaf node, we'll only split nodes once they exceed our capacity k. This gives us a tree whose leaves are our k-buckets that partition the global area, which we will use for garbage collection later.\nJust for fun, I decided to write the quadtree-of-ring-buffers as an in-memory data structure in Zig, and expose it to NodeJS as a native NAPI module.\npub const Quadrant = enum(u2) { sw = 0, nw = 1, se = 2, ne = 3 };\n\npub const NodeId = u32; // zero for empty slot\n\npub const Node = struct {\n\tne: NodeId,\n\tnw: NodeId,\n\tsw: NodeId,\n\tse: NodeId,\n\n\tcapacity: usize,\n\n\tpub inline fn getQuadrant(self: Node, q: Quadrant) NodeID {\n\t\t// ...\n\t}\n\n\tpub inline fn isEmpty(self: Node) bool {\n\t\treturn self.ne == 0 and self.nw == 0 and self.sw == 0 and self.se == 0;\n\t}\n\n\t// ...\n};\n\n// represents a square map tile\npub const Tile = struct {\n\tcenter: @Vector(2, f32),\n\tsize: f32, // side length of tile\n\n\t/// return a child quadrant\n\tpub fn divide(self: Tile, q: Quadrant) Tile {\n\t\t// ...\n\t}\n\n\t/// locate a point within a child quadrant\n\tpub fn locate(self: Tile, point: @Vector(2, f32)) Quadrant {\n\t\t// ...\n\t}\n};\n\n// our quadtree-of-ring-buffers spatio-temporal cache\nconst QtCache = struct {\n\troot: Tile, // bounding square for the global map\n\n\t// NodeId values are an index into nodes.items.\n\t// the first element of nodes.items is the root node.\n\tnodes: std.ArrayList(Node),\n\n\t// ...\n};\nIn addition to this capacity number, each quadtree node also has its own buffer for the most recent k posts within its tile area. Since we need to index a constant stream of new posts, we can use a ring buffer to avoid shifting existing contents around.\nconst std = @import(\"std\");\n\npub fn RingBuffer(comptime T: type, comptime K: usize) type {\n    return struct {\n        const Self = @This();\n\n        pub const Ring = struct {\n            head: []const T,\n            tail: []const T,\n        };\n\n        items: [K]T = undefined,\n        start: usize = 0,\n        len: usize = 0,\n\n        pub fn reset(self: *Self) void {\n            self.start = 0;\n            self.len = 0;\n        }\n\n        pub fn push(self: *Self, item: T) void {\n            // ... blah blah blah\n        }\n\n        pub fn getRing(self: *const Self) Ring {\n            // ... blah blah blah\n        }\n    };\n}\nThen we add a ring buffer for posts to each of our quadtree nodes. For each post, we'll store both the post id (a SQLite rowid) and also the x/y coordinates of the user. The rest of the post and user data are persisted in a SQLite database; posts get garbage-collected in the background once they rotate out of the leaf bucket's ring buffer.\npub const PostId = u32;\npub const Post = struct {\n    id: PostId,\n    position: @Vector(2, f32)\n\n    // these ids are monotonic rowids from SQLite so they trivially sort by time\n    pub fn lessThan(_: void, lhs: Post, rhs: Post) bool {\n        return lhs.id < rhs.id;\n    }\n};\n\nconst K = 24;\n\npub const Node = struct {\n\t// ...\n\n\tbuffer: RingBuffer(Post, K),\n};\nThis means that inserting a post into the quadtree just involves descending the tree to the appropriate leaf bucket, pushing the post onto each node's buffer along the way.\npub const QtCache = struct {\n\t// ...\n\n\tpub inline fn observe(self: *QtCache, post: Post) void {\n\t\tif (self.tree.items.len > 0) {\n\t\t\tself.observeNode(0, self.root, post);\n\t\t}\n\t}\n\n\tfn observeNode(self: *QtCache, id: NodeId, tile: Tile, post: Post) void {\n\t\tself.tree.items[idx].buffer.push(post);\n\n\t\tconst quadrant = tile.locate(post.position);\n\t\tconst child = self.tree.items[id].getQuadrant(quadrant);\n\t\tif (child != 0) {\n\t\t\tself.observeNode(child, tile.divide(quadrant), item);\n\t\t}\n\t}\n};\nQuerying is only a little more complicated. The trivial case is querying an area exactly equal to a quadtree node tile, but in general queries can be any rectangular area. This means we have to traverse all quadtree nodes that intersect the query area, and collect the top-k results in a min-heap as we go. (We don't need to recurse into a node's children if it is entirely contained within the query area.)\nFirst we make a little generic MinHeap...\npub fn MinHeap(comptime T: type, comptime K: usize) type {\n    return struct {\n        const Self = @This();\n\n        heap: [K]T = undefined,\n        size: usize = 0,\n\n        pub fn init() Self {\n            // ...\n        }\n\n        pub fn clear(self: *Self) void {\n            // ...\n        }\n\n\t    pub fn add(self: *Self, value: T) void {\n\t\t    // ...\n\t    }\n\n\t\tpub inline fn getItems(self: Self) []const T {\n\t\t\treturn self.heap[0..self.size];\n\t\t}\n    };\n}\n... then we add it to our QtCache and write the recursive queryNode.\nconst K = 24;\n\npub const QtCache = struct {\n\troot: Tile, // bounding square for the global map\n\n\t// NodeId values are an index into nodes.items.\n\t// the first element of nodes.items is the root node.\n\tnodes: std.ArrayList(Node),\n\n\theap: MinHeap(PostId, K)\n\n\t// ...\n\n\tpub const Query = struct {\n\t\tmin: @Vector(2, f32),\n\t\tmax: @Vector(2, f32),\n\n\t\t/// do the query rectangle and the area tile intersect?\n\t\tpub inline fn intersect(self: Query, tile: Tile) bool {\n\t\t\t// ...\n\t\t}\n\n\t\t/// does the query rectangle include the point?\n\t\tpub inline fn includes(self: Query, p: @Vector(2, f32)) bool {\n\t\t\t// ...\n\t\t}\n\t};\n\n\tpub fn query(self: *QtCache, q: Query) []const PostId {\n\t\t// use size of the query rectangle to derive a\n\t\t// lower bound of quadtree node size.\n\t\t// we won't traverse into children below this size.\n\t\tconst divisor: f32 = 2;\n\t\tconst unit = @ceil(@log2(@reduce(.Max, q.max - q.min) / divisor));\n\t\tconst threshold = std.math.pow(f32, 2, unit);\n\n\t\tself.heap.clear();\n\t\tself.queryNode(0, self.root, q, s);\n\n\t\t// the top-k posts here aren't actually sorted within\n\t\t// themselves since they're in heap order, but we can\n\t\t// just sort them on the NodeJS side before resolving\n\t\t// the ids to URIs.\n\t\treturn self.heap.getItems();\n\t}\n\n\tfn queryNode(self: *QtCache, id: NodeId, tile: Tile, q: Query, threshold: f32) void {\n\t\tif (!q.intersect(tile)) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst node = self.tree.items[id];\n\t\tif (node.isEmpty() or tile.s <= threshold) {\n\t\t\tconst ring = node.buffer.getRing();\n\t\t\tfor (ring.head) |post|\n\t\t\t\tif (q.includes(post.position)) self.heap.add(post.id);\n\t\t\tfor (ring.tail) |post|\n\t\t\t\tif (q.includes(post.position)) self.heap.add(post.id);\n\t\t} else {\n\t\t\tif (node.ne != 0) self.queryNode(node.ne, tile.divide(.ne), q, threshold);\n\t\t\tif (node.nw != 0) self.queryNode(node.nw, tile.divide(.nw), q, threshold);\n\t\t\tif (node.sw != 0) self.queryNode(node.sw, tile.divide(.sw), q, threshold);\n\t\t\tif (node.se != 0) self.queryNode(node.se, tile.divide(.se), q, threshold);\n\t\t}\n\t}\n};\nNice! An in-memory spatio-temporal index! And we actually wrote both observe and query as zero-allocation methods!\nI won't go over compiling the quadtree to a native NodeJS module, but you can look at the Zig build configuration in the source repo if you're interested.\nI deployed all this to fly.io for ~$10/month, including a persistent volume for the SQLite databases. Bluesky currently generates ~100 posts per second, and the index caches around 10 million total recent posts with less than 1GB total memory usage. Spatial queries from the Aurora web client take just around 1-3ms inside QtCache, dominated by ~12-20ms of network overhead to and from the client.\nIf your browser supports WebGPU, you can check out the map yourself at https://aurora.ndimensional.xyz and pop open the left sidebar to see the spatial feed.","length":12495,"excerpt":"Joel Gustafson","siteName":null,"publishedTime":null}