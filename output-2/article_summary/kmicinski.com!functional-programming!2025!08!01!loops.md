*   **Equivalence:** Tail-recursive functions are computationally equivalent to iterative loops.
*   **Standard Recursion & Performance:** Standard recursive functions build up stack frames for each call to store intermediate results. This results in O(n) space complexity for a data structure of size n and can be inefficient due to the overhead of memory writes and potential cache misses.
*   **Iteration & Performance:** Loops maintain a constant memory footprint (O(1) space) by using accumulator variables that are updated in place. This avoids stack growth and is generally more performant.
*   **Tail Call:** A function call is in "tail position" if its result is immediately returned by the outer function without any further computation. This is a syntactic property that a compiler can statically identify.
*   **Tail Call Optimization (TCO):** A compiler can optimize a tail call by replacing the standard `call` instruction (which pushes a new stack frame) with a `jmp` instruction (which jumps to the beginning of the function). This transforms the recursion into an imperative loop, eliminating stack space growth.
*   **TCO Mechanism:** With TCO, the arguments for the next recursive step overwrite the current function's arguments in memory, effectively mutating state in a manner identical to a loop's iteration variables.
*   **Continuation-Passing Style (CPS):** Any function, even one with multiple recursive calls, can be systematically transformed so that all calls are tail calls. This technique, known as CPS conversion, effectively eliminates the program stack in favor of heap-allocated continuation objects.
